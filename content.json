{"meta":{"title":"盛克思的博客","subtitle":"光看不练是退步！","description":"对于JavaScript(ES6)、VUE、NodeJS、等相关技术的实战经验分享","author":"shengkesi","url":"https://www.shengkesi.cn"},"pages":[{"title":"Page not found","date":"2019-07-01T05:37:22.978Z","updated":"2019-03-01T02:27:32.000Z","comments":false,"path":"/404.html","permalink":"https://www.shengkesi.cn//404.html","excerpt":"","text":""},{"title":"盛克思简介","date":"2018-09-17T00:46:50.000Z","updated":"2019-05-04T08:11:46.000Z","comments":false,"path":"about/index.html","permalink":"https://www.shengkesi.cn/about/index.html","excerpt":"","text":"About me13年3月从事前端开发至今 现研究方向现研究mock.js(模拟接口请求)，eslint + prettier(语法检查和格式化工具)，来辅助vue-cli3项目的开发项目还在努力维护中，为保证功能完善，给大家铺路。 2019自己决定重新调整自己在前端领域的发展方向，努力拓展自己未涉及的领域。 2019-05-04利用周六日的闲暇时间，填了搭建react + typescript 的一些坑，框架已经成型，项目中想到的，需要的配置都有了；好的前端框架搭建是做一个可维护，可拓展项目的基础，不会给以后接手的程序员带来麻烦。 2019-03-10几天的努力之下，自己的react项目总算成型，决定新建一个“发布”分支，以供以后开发用。 2019-03-04开始深入研究reactjs，弥补之前的浅尝辄止；一开始自己用官方的项目生成器生成了一个简单的架构，自己从这个简化版逐步加入babel, webpack, eslint 等相关的配置，有兴趣的朋友可以移步 react的基础之上进行引入webpack、eslint、babel的框架搭建, 但是你仔细阅读react项目下的 READEME.md, 你就会发现我绕了远路，其实react提供了 npm run eject 来注入webpack, eslint, label 等相关依赖和配置，可能这就是react给大家提供的 脚手架 吧，需要注意的是：这个命令只能执行一次，而且不可逆转。 2019-02-25为博客每篇文章（包括首页）也显示字数统计和阅读时长， Nginx 优化配置 - Gzip 压缩, 博文分享换成addthis。 2019-02-22为博客加入了百度统计功能，实际的去观察网站访问情况 2019-02-15为自己的博客网站进行了SEO，包括百度搜索和谷歌搜索，并加入了相关的站点地图，在hexo中添加百度主动推送功能, 每次部署主动推送一次 2019-02-09把自己的博客成功迁移到自己服务器上，配置了git远程资源库，配置nginx ：能够用https协议访问博客地址，强制http转https协议访问博客，http://shengkesi.cn -&gt; https://shengkesi.cn http://www.shengkesi.cn -&gt; https://www.shengkesi.cn 2019-01-27服务器部署gitlab失败后，自己在家测试了一下ping自己的博客的github地址，和ping自己的服务器对比了一下，发现github的延迟132ms,而且丢包；自己的服务器74ms，毅然决定把自己的博客网站迁移到自己的服务器上，一开始弄了FTP，但是有些舍近求远了；发现其实自己在服务器端搭建跟本地一样的开发环境即可，只是多了ngnix的安装和配置。 2019-01-25趁着工作午休时间，把自己博客的评论功能加上了，并填了首页插入的图片不显示的问题的坑。 2019-01-24经过折腾了linux安装docker, 并且在docker内装了jenkins后，感觉缺点什么，想弄个GitLab，在服务器存储自己的代码。踩坑开始，经过层层扒坑埋坑的过程，总算把GitLab建立起来了，但是访问是502页面。最后找到原因：由于服务配置太低（CPU 1核，内存2GB），无法满足Gitlab的（CPU 2核，内存4GB）的要求，页面报502，踩坑结束。 2018研究vue2.0 VUEX状态管理机制 webpack 等"},{"title":"archives","date":"2019-07-01T05:37:23.120Z","updated":"2019-03-01T02:27:32.000Z","comments":false,"path":"archives/index.html","permalink":"https://www.shengkesi.cn/archives/index.html","excerpt":"","text":""},{"title":"categories","date":"2019-07-01T05:37:23.178Z","updated":"2019-03-01T02:27:32.000Z","comments":false,"path":"categories/index.html","permalink":"https://www.shengkesi.cn/categories/index.html","excerpt":"","text":""},{"title":"","date":"2019-07-01T05:37:23.219Z","updated":"2019-03-01T02:27:32.000Z","comments":true,"path":"categories/package.json","permalink":"https://www.shengkesi.cn/categories/package.json","excerpt":"","text":"{\"dependencies\":{\"hexo-deployer-git\":\"^0.3.0\"}}"},{"title":"tags","date":"2019-07-01T05:37:23.270Z","updated":"2019-03-01T02:27:32.000Z","comments":false,"path":"tags/index.html","permalink":"https://www.shengkesi.cn/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"ES6 的新特性","slug":"ECMAScript6-New-Features","date":"2019-05-18T10:26:14.000Z","updated":"2019-05-18T10:37:20.000Z","comments":true,"path":"ECMAScript6-New-Features/","link":"","permalink":"https://www.shengkesi.cn/ECMAScript6-New-Features/","excerpt":"","text":"写这篇文章的目的就是告诉前端的同学们，ES6 已经是前端程序员必不可少的技能之一，后期再追加 Typescript 的新语法 关键字 let 与 const 的应用大家都知道，ES5 中的 var 是一种无数据类型的定义（仅在这提及一下Typescript新语法，每定义一个变量必然需要声明数据类型，比如：const order: object = {}）而且这个 var 会使变量提升，JavaScript 仅提升声明，而不提升初始化，请看下面的例子： 1","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.shengkesi.cn/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.shengkesi.cn/tags/JavaScript/"}]},{"title":"在 react 项目的基础上增加一些配置（typescript支持，webpack别名等）","slug":"create-react-app-complex","date":"2019-03-12T01:47:05.000Z","updated":"2019-05-04T08:11:46.000Z","comments":true,"path":"create-react-app-complex/","link":"","permalink":"https://www.shengkesi.cn/create-react-app-complex/","excerpt":"引言react脚手架并不能直接运用到项目中去，需要改造，自己进行了进一步探索，总结创建项目的心酸历程 创建项目的流程 npx create-react-app jelly3 备注：你的环境没有全局安装npx，放心，它会自动安装上并执行创建项目的命令 cd jelly3 切换到自己创建项目根目录下 yarn eject yarn start 启动项目","text":"引言react脚手架并不能直接运用到项目中去，需要改造，自己进行了进一步探索，总结创建项目的心酸历程 创建项目的流程 npx create-react-app jelly3 备注：你的环境没有全局安装npx，放心，它会自动安装上并执行创建项目的命令 cd jelly3 切换到自己创建项目根目录下 yarn eject yarn start 启动项目 接下来就是思考自己的项目结构了如果你刚开始一个项目，不要花超过五分钟在选择一个文件结构上。从以上方法（或者你自己想到的）中任意挑一个然后开始编程吧！在写完一些真实的代码之后，你可能会想重新考虑它。 @歌特式灵魂摆渡人www.jianshu.com/p/eb7d518b05b8 引入路径别名发现更改目录结构后，相对路径的名字写起来很麻烦，想跟以前VUE项目一样，src 路径 以 别名 “@” 代替我们可以通过使用 webpack 中的 resolve.alias 配置别名，将某些文件目录配置成固定的引入。例如： 我们可以将 ../../src 这样的相对路径的目录，设置成一个 @ 别名， 以后就可以用 @ 代替这个目录引入就行了，而不需要写一坨 ../../../ 1234567891011const path = require(&apos;path&apos;);module.exports = &#123; ... resolve: &#123; alias: &#123; &apos;@&apos;: path.resolve(__dirname, &apos;../src&apos;) &#125; &#125;, ...&#125;; 给React项目添加TypeScript支持请参阅给React项目添加TypeScript支持, 多少跟实际项目有些出入，需要灵活变通，与官网的配置结合看最佳。熟悉webpack配置和总览生成项目的配置后，我发现已经对TypeScript部分支持（未对.ts和.tsx进行webpack解析）注：TypeScript 官网 有 React &amp; Webpack 这篇教程，但是有需要改进的地方, 比如 ts-loader 比 awesome-typescript-loader 打包速度更快， 构建项目大多数用 ts-loader, 详见Speed of Awesome-typescript-loader vs ts-loader 加入代码语法格式检查工具eslint + tslint 并不能满足自己的代码洁癖，后又引入了prettier vscode + prettier 专治代码洁癖，经过艰苦的VSCode插件和配置文件的调试过程，代码检查机制总算配置好了。 解决相关的问题 .tsx 文件中引入的 webpack 别名，TS语法检查报错的问题详见一次解决React+TypeScript+Webpack 别名（alias）找不到问题的过程 同时，当天发现react项目存在的问题就是 package.json 文件中，没有开发环境依赖和生产环境依赖的区分，把所有的依赖全部写入到了生产依赖中，如下 package.json123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121&#123; &quot;name&quot;: &quot;jelly3&quot;, &quot;version&quot;: &quot;0.2.0&quot;, &quot;private&quot;: true, &quot;dependencies&quot;: &#123; &quot;@babel/core&quot;: &quot;7.2.2&quot;, &quot;@svgr/webpack&quot;: &quot;4.1.0&quot;, &quot;babel-core&quot;: &quot;7.0.0-bridge.0&quot;, &quot;babel-eslint&quot;: &quot;9.0.0&quot;, &quot;babel-jest&quot;: &quot;23.6.0&quot;, &quot;babel-loader&quot;: &quot;8.0.5&quot;, &quot;babel-plugin-named-asset-import&quot;: &quot;^0.3.1&quot;, &quot;babel-preset-react-app&quot;: &quot;^7.0.1&quot;, &quot;bfj&quot;: &quot;6.1.1&quot;, &quot;case-sensitive-paths-webpack-plugin&quot;: &quot;2.2.0&quot;, &quot;css-loader&quot;: &quot;1.0.0&quot;, &quot;dotenv&quot;: &quot;6.0.0&quot;, &quot;dotenv-expand&quot;: &quot;4.2.0&quot;, &quot;eslint&quot;: &quot;5.12.0&quot;, &quot;eslint-config-react-app&quot;: &quot;^3.0.7&quot;, &quot;eslint-loader&quot;: &quot;2.1.1&quot;, &quot;eslint-plugin-flowtype&quot;: &quot;2.50.1&quot;, &quot;eslint-plugin-import&quot;: &quot;2.14.0&quot;, &quot;eslint-plugin-jsx-a11y&quot;: &quot;6.1.2&quot;, &quot;eslint-plugin-react&quot;: &quot;7.12.4&quot;, &quot;file-loader&quot;: &quot;2.0.0&quot;, &quot;fork-ts-checker-webpack-plugin-alt&quot;: &quot;0.4.14&quot;, &quot;fs-extra&quot;: &quot;7.0.1&quot;, &quot;html-webpack-plugin&quot;: &quot;4.0.0-alpha.2&quot;, &quot;identity-obj-proxy&quot;: &quot;3.0.0&quot;, &quot;jest&quot;: &quot;23.6.0&quot;, &quot;jest-pnp-resolver&quot;: &quot;1.0.2&quot;, &quot;jest-resolve&quot;: &quot;23.6.0&quot;, &quot;jest-watch-typeahead&quot;: &quot;^0.2.1&quot;, &quot;mini-css-extract-plugin&quot;: &quot;0.5.0&quot;, &quot;node-sass&quot;: &quot;^4.12.0&quot;, &quot;optimize-css-assets-webpack-plugin&quot;: &quot;5.0.1&quot;, &quot;pnp-webpack-plugin&quot;: &quot;1.2.1&quot;, &quot;postcss-flexbugs-fixes&quot;: &quot;4.1.0&quot;, &quot;postcss-loader&quot;: &quot;3.0.0&quot;, &quot;postcss-preset-env&quot;: &quot;6.5.0&quot;, &quot;postcss-safe-parser&quot;: &quot;4.0.1&quot;, &quot;react&quot;: &quot;^16.8.3&quot;, &quot;react-app-polyfill&quot;: &quot;^0.2.1&quot;, &quot;react-dev-utils&quot;: &quot;^7.0.3&quot;, &quot;react-dom&quot;: &quot;^16.8.3&quot;, &quot;resolve&quot;: &quot;1.10.0&quot;, &quot;sass-loader&quot;: &quot;7.1.0&quot;, &quot;style-loader&quot;: &quot;0.23.1&quot;, &quot;terser-webpack-plugin&quot;: &quot;1.2.2&quot;, &quot;url-loader&quot;: &quot;1.1.2&quot;, &quot;webpack&quot;: &quot;4.28.3&quot;, &quot;webpack-dev-server&quot;: &quot;3.1.14&quot;, &quot;webpack-manifest-plugin&quot;: &quot;2.0.4&quot;, &quot;workbox-webpack-plugin&quot;: &quot;3.6.3&quot; &#125;, &quot;scripts&quot;: &#123; &quot;start&quot;: &quot;node scripts/start.js&quot;, &quot;build&quot;: &quot;node scripts/build.js&quot;, &quot;test&quot;: &quot;node scripts/test.js&quot; &#125;, &quot;eslintConfig&quot;: &#123; &quot;extends&quot;: &quot;react-app&quot; &#125;, &quot;browserslist&quot;: [ &quot;&gt;0.2%&quot;, &quot;not dead&quot;, &quot;not ie &lt;= 11&quot;, &quot;not op_mini all&quot; ], &quot;jest&quot;: &#123; &quot;collectCoverageFrom&quot;: [ &quot;src//*.&#123;js,jsx,ts,tsx&#125;&quot;, &quot;!src//.d.ts&quot; ], &quot;resolver&quot;: &quot;jest-pnp-resolver&quot;, &quot;setupFiles&quot;: [ &quot;react-app-polyfill/jsdom&quot; ], &quot;testMatch&quot;: [ &quot;&lt;rootDir&gt;/src//tests//.&#123;js,jsx,ts,tsx&#125;&quot;, &quot;&lt;rootDir&gt;/src/*/?(.)(spec|test).&#123;js,jsx,ts,tsx&#125;&quot; ], &quot;testEnvironment&quot;: &quot;jsdom&quot;, &quot;testURL&quot;: &quot;http://localhost&quot;, &quot;transform&quot;: &#123; &quot;^.+\\.(js|jsx|ts|tsx)$&quot;: &quot;&lt;rootDir&gt;/node_modules/babel-jest&quot;, &quot;^.+\\.css$&quot;: &quot;&lt;rootDir&gt;/config/jest/cssTransform.js&quot;, &quot;^(?!.*\\.(js|jsx|ts|tsx|css|json)$)&quot;: &quot;&lt;rootDir&gt;/config/jest/fileTransform.js&quot; &#125;, &quot;transformIgnorePatterns&quot;: [ &quot;[/\\\\]node_modules[/\\\\].+\\.(js|jsx|ts|tsx)$&quot;, &quot;^.+\\.module\\.(css|sass|scss)$&quot; ], &quot;moduleNameMapper&quot;: &#123; &quot;^react-native$&quot;: &quot;react-native-web&quot;, &quot;^.+\\.module\\.(css|sass|scss)$&quot;: &quot;identity-obj-proxy&quot; &#125;, &quot;moduleFileExtensions&quot;: [ &quot;web.js&quot;, &quot;js&quot;, &quot;web.ts&quot;, &quot;ts&quot;, &quot;web.tsx&quot;, &quot;tsx&quot;, &quot;json&quot;, &quot;web.jsx&quot;, &quot;jsx&quot;, &quot;node&quot; ], &quot;watchPlugins&quot;: [ &quot;E:\\Study\\jelly3\\node_modules\\jest-watch-typeahead\\filename.js&quot;, &quot;E:\\Study\\jelly3\\node_modules\\jest-watch-typeahead\\testname.js&quot; ] &#125;, &quot;babel&quot;: &#123; &quot;presets&quot;: [ &quot;react-app&quot; ] &#125;&#125;根据我以往的经验，把这些依赖进行了拆解，分成开发依赖（devDependencies，其中大部分是开发依赖）和 生产依赖 （dependencies）最新的 package.json 相关配置，请参考我的 github - jelly3 typescript里面引入图片时，TS语法检查报错，项目没办法正常启动参阅了(https://stackoverflow.com/questions/43638454/webpack-typescript-image-import?rq=1)，解决了这个问题。 为项目引入react-router(v4) 、antd-mobileyarn add react-router-domantd-mobile 请参照官网进行配置和引入，最好是按需加载遇到的问题：如果babel-plugin-import按需加载的js不符合tslint规范，怎么办？修改 tslint 的语法检查配置tsconfig.json 中添加 “allowSyntheticDefaultImports”: true, // 允许模块没有默认导出 浏览器兼容问题—babel-polyfill代码分割，路由动态加载（react-loadable）(react-loadable)[https://github.com/jamiebuilds/react-loadable] 高阶组件：路由守卫模拟VUE的路由守卫机制 react按需引入(lodash)[https://www.cnblogs.com/savokiss/p/8514868.html]定制antd-mobile主题vsCode安装函数注释插件（KoroFileHeader ）和git源代码管理插件（GitLens）、Import Cost、REST Client、vscode-icons添加webpack对less和sass的解析配置","categories":[{"name":"React","slug":"React","permalink":"https://www.shengkesi.cn/categories/React/"}],"tags":[{"name":"React","slug":"React","permalink":"https://www.shengkesi.cn/tags/React/"},{"name":"TypeScript","slug":"TypeScript","permalink":"https://www.shengkesi.cn/tags/TypeScript/"}]},{"title":"react的基础之上进行引入webpack、eslint、babel的框架搭建","slug":"create-react-app-simple","date":"2019-03-04T07:13:00.000Z","updated":"2019-05-04T08:11:46.000Z","comments":true,"path":"create-react-app-simple/","link":"","permalink":"https://www.shengkesi.cn/create-react-app-simple/","excerpt":"引言开始深入研究reactjs，弥补之前的浅尝辄止；一开始自己用官方的项目生成器生成了一个简单的架构，自己从这个简化版逐步加入babel, webpack, eslint 等相关的配置，有兴趣的朋友可以移步 react的基础之上进行引入webpack、eslint、babel的框架搭建, 但是你仔细阅读react项目下的 READEME.md, 你就会发现我绕了远路，其实react提供了 yarn eject 来注入webpack, eslint, label 等相关依赖和配置，可能这就是react给大家提供的 脚手架 吧 需要注意的是：这个命令只能执行一次，而且不可逆转。 虽说自己饶了远路，但是还是学到些东西的，也温习了一些 webpack，babel 的配置和原理等，想亲自动手，亲自实践的朋友按照如下步骤进行就行，我已经为你们绕过了一些坑比如：babel 升级 6.x 到 7.x, 请参阅 babel 7.x 和 webpack 4.x 配置vue项目, 如果以下步骤有什么不妥之处，欢迎大家给我评论，我会及时修正并回复大家的问题。","text":"引言开始深入研究reactjs，弥补之前的浅尝辄止；一开始自己用官方的项目生成器生成了一个简单的架构，自己从这个简化版逐步加入babel, webpack, eslint 等相关的配置，有兴趣的朋友可以移步 react的基础之上进行引入webpack、eslint、babel的框架搭建, 但是你仔细阅读react项目下的 READEME.md, 你就会发现我绕了远路，其实react提供了 yarn eject 来注入webpack, eslint, label 等相关依赖和配置，可能这就是react给大家提供的 脚手架 吧 需要注意的是：这个命令只能执行一次，而且不可逆转。 虽说自己饶了远路，但是还是学到些东西的，也温习了一些 webpack，babel 的配置和原理等，想亲自动手，亲自实践的朋友按照如下步骤进行就行，我已经为你们绕过了一些坑比如：babel 升级 6.x 到 7.x, 请参阅 babel 7.x 和 webpack 4.x 配置vue项目, 如果以下步骤有什么不妥之处，欢迎大家给我评论，我会及时修正并回复大家的问题。 创建项目的流程 npx create-react-app jelly备注：你的环境没有全局安装npx，放心，它会自动安装上并执行创建项目的命令 cd jelly 切换到自己创建项目根目录下 导入 react-dom 、react-router-dom 、 redux 、 react-redux 、lodash 依赖包yarn add react-dom react-router-dom redux react-redux lodash 安装 Webpack, 现在最流行的模块打包工具yarn add webpack webpack-cli webpack-dev-server webpack-merge –dev 安装一些必要的 Webpack 打包插件 和 eslintyarn add html-webpack-plugin copy-webpack-plugin css-loader file-loader eslint babel-eslint –dev 安装Babel, 可以把ES6转换为ES5，注意Babel最新的V6版本分为babel-cli和babel-core两个模块，这里只需要用babel-core即可yarn add @babel/core –dev 安装其他的babel依赖yarn add @babel/polyfill @babel/runtime @babel/plugin-transform-runtime @babel/preset-env @babel/preset-react –dev 安装 cross-env ， cross-env能跨平台地设置及使用环境变量yarn add cross-env –dev 打开 package.json , 添加或者修改下面的命令脚本 package.json12345&quot;scripts&quot;: &#123; &quot;start&quot;: &quot;cross-env NODE_ENV=development webpack-dev-server --cache --colors --profile --progress -d&quot;, &quot;build&quot;: &quot;cross-env NODE_ENV=production webpack --cache --colors --profile --progress --hide-modules&quot;&#125; 命令行输入 yarn start 将要启动 webpack dev server.命令行输入 yarn build 将会进行生产环境打包. 要想成功用webpack打包，还需要 webpack.config.js 和 webpack.ini.js , .babelrc","categories":[{"name":"React","slug":"React","permalink":"https://www.shengkesi.cn/categories/React/"}],"tags":[{"name":"React","slug":"React","permalink":"https://www.shengkesi.cn/tags/React/"}]},{"title":"JS 的深拷贝与浅拷贝","slug":"deep-copy-and-shallow-copy-for-JavaScript","date":"2019-02-24T01:21:09.000Z","updated":"2019-03-01T02:27:32.000Z","comments":true,"path":"deep-copy-and-shallow-copy-for-JavaScript/","link":"","permalink":"https://www.shengkesi.cn/deep-copy-and-shallow-copy-for-JavaScript/","excerpt":"原文链接作者：ziwei3749https://segmentfault.com/a/1190000012828382 这篇文章的受众 第一类,业务需要,急需知道如何深拷贝JS对象的开发者。 第二类,希望扎实JS基础,将来好去面试官前秀操作的好学者。 写给第一类读者你只需要一行黑科技代码就可以实现深拷贝 123456var copyObj = &#123; name: &apos;ziwei&apos;, arr : [1,2,3]&#125;var targetObj = JSON.parse(JSON.stringify(copyObj)) 此时 copyObj.arr !== targetObj.arr 已经实现了深拷贝 别着急走,利用window.JSON的方法做深拷贝存在2个缺点: 如果你的对象里有函数,函数无法被拷贝下来 无法拷贝copyObj对象原型链上的属性和方法","text":"原文链接作者：ziwei3749https://segmentfault.com/a/1190000012828382 这篇文章的受众 第一类,业务需要,急需知道如何深拷贝JS对象的开发者。 第二类,希望扎实JS基础,将来好去面试官前秀操作的好学者。 写给第一类读者你只需要一行黑科技代码就可以实现深拷贝 123456var copyObj = &#123; name: &apos;ziwei&apos;, arr : [1,2,3]&#125;var targetObj = JSON.parse(JSON.stringify(copyObj)) 此时 copyObj.arr !== targetObj.arr 已经实现了深拷贝 别着急走,利用window.JSON的方法做深拷贝存在2个缺点: 如果你的对象里有函数,函数无法被拷贝下来 无法拷贝copyObj对象原型链上的属性和方法 当然,你明确知道他们的缺点后,如果他的缺点对你的业务需求没有影响,就可以放心使用了,一行原生代码就能搞定。目前我在开发业务场景中,大多还真可以忽略上面2个缺点。往往需要深拷贝的对象里没有函数,也不需要拷贝它原型链的属性。 写给第二类读者下面我会尽可能全面的讲解清楚JS里对象的拷贝,要讲清楚拷贝,你需要一点点前置知识 你需要的前置知识: 理解JS里的引用类型和值类型的区别,知道Obj存储的只是引用 对原型链有基本了解 关于对象拷贝的全部: 深拷贝、浅拷贝是什么 深拷贝、浅拷贝在业务里的最常见的应用场景 深拷贝和浅拷贝的实现方式 总结与建议 1. 深拷贝、浅拷贝是什么我们讨论JS对象深拷贝、浅拷贝的前提 只有对象里嵌套对象的情况下,才会根据需求讨论,我们要深拷贝还是浅拷贝。 比如下面这种对象 1234var obj1 = &#123; name: &apos;ziwei&apos;, arr : [1,2,3]&#125;因为,如果是类似这样{name: ‘ziwei’},没有嵌套对象的对象的话,就没必要区分深浅拷贝了。只有在有嵌套的对象时,深拷贝和浅拷贝才有区别浅拷贝是什么样子的 (我们暂时不管具体如何实现,因为下面会单讲)调用shallowCopy()后,obj2拷贝obj1所有的属性。但是obj2.arr和obj1.arr是不同的引用,指向同一个内存空间12345var obj2 = shallowCopy( obj1 , &#123;&#125;)console.log( obj1 !== obj2 ) // true 无论哪种拷贝,obj1和obj2一定都是2个不同的对象(内存空间不同)console.log( obj2.arr === obj1.arr ) // true 他们2个对象里arr的引用,指向【相同的】内存空间 所以, 2个obj经过拷贝后,虽然他们属性相同,也的确是不同的对象,但他们内部的obj都是指向同一个内存空间,这种我们叫浅拷贝 深拷贝是什么样子的 (我们暂时不管具体如何实现,因为下面会单讲) 调用deepCopy()后,obj2拷贝obj1所有的属性,而且obj2.arr和obj1.arr是指向不同的内存空间, 2个obj2除了拷贝了一样的属性,没有任何其他关联。 12345var obj2 = deepCopy( obj1 , &#123;&#125;)console.log( obj1 !== obj2 ) // true 无论哪种拷贝,obj1和obj2一定都是2个不同的对象(内存空间不同)console.log( obj2.arr === obj1.arr ) // false 他们2个对象里arr的引用,指向【不同的】内存空间 所以, 2个obj经过拷贝后,除了拷贝下来相同的属性之外,没有任何其他关联的2个对象,这种我们叫深拷贝 2. 深拷贝在业务里的最常见的应用场景举个栗子,业务需求是 : 一个表格展示商品各种信息,点击【同意】时,是可以弹出对话框调整商品数量的。 这种业务需求下,我们就会用到对象的深拷贝。因为【商品表格】的属性和【调整商品表格】的属性几乎一样,我们需要拷贝。 下面的伪代码和图片就是展示使用浅拷贝存在的问题 这样得到的adjustTableArr和tableArr里,内部对象都是相同的,所以就出现了图中红线标注的情况, 当我们修改【调整商品表格】里的商品数量时,【商品表格】也跟着改变了,这并不是我们想要的 123456789101112// 表格对象的数据结构var tableArr = [ &#123;goods_name : &apos;长袖腰背夹&apos; , code : &apos;M216C239E0864&apos; , num : &apos;2&apos;&#125;, &#123;goods_name : &apos;长袖腰背夹&apos; , code : &apos;M216C240B0170&apos; , num : &apos;3&apos;&#125;, &#123;goods_name : &apos;短塑裤&apos; , code : &apos;M216D241C04106&apos; , num : &apos;3&apos;&#125;, ] var adjustTableArr = [] // 调整表格用的数组for (var key in tableArr) &#123; // 浅拷贝 adjustTableArr[key] = tableArr[key]&#125; 而实际上,我们希望这2个表格里的数据完全独立,互不干扰,只有在确认调整之后才刷新商品数量。 这种情况下我们就可以使用前面说的深拷贝的一行黑科技 1var adjustTableArr = JSON.parse(JSON.stringify(tableArr)) 还记得它的缺陷吗? 对象里的函数无法被拷贝,原型链里的属性无法被拷贝。这里就对业务没有影响,可以很方便的深拷贝。 3. 深拷贝和浅拷贝的实现方式其实JQ里已经有$.extend()函数,实现就是深拷贝和浅拷贝的功能。有兴趣的小伙伴也可以看看源码。 浅拷贝 浅拷贝比较简单,就是用for in 循环赋值 123456789function shallowCopy(source, target = &#123;&#125;) &#123; var key; for (key in source) &#123; if (source.hasOwnProperty(key)) &#123; // 意思就是proto上面的属性,我不拷贝 target[key] = source[key]; &#125; &#125; return target;&#125; 深拷贝的实现 深拷贝,就是遍历那个被拷贝的对象 判断对象里每一项的数据类型 如果不是对象类型,就直接赋值,如果是对象类型,就再次调用deepCopy,递归的去赋值。 1234567891011121314function deepCopy(source, target = &#123;&#125;) &#123; var key; for (key in source) &#123; if (source.hasOwnProperty(key)) &#123; // 意思就是proto上面的属性,我不拷贝 if (typeof(source[key]) === &quot;object&quot;) &#123; // 如果这一项是object类型,就递归调用deepCopy target[key] = Array.isArray(source[key]) ? [] : &#123;&#125;; deepCopy(source[key], target[key]); &#125; else &#123; // 如果不是object类型,就直接赋值拷贝 target[key] = source[key]; &#125; &#125; &#125; return target;&#125; 以上的无论深、浅拷贝,都用了source.hasOwnProperty(key),意思是判断这一项是否是其自有属性,是的话才拷贝,不是就不拷贝。 也就是说proto上面的属性,我不拷贝。这个其实你可以根据业务需求,来决定加上和这个条件 (JQ的$.extend()是会连proto上的属性也拷贝下来的,但是是直接拷贝到对象上,而不是放到之前的proto上) 4. 总结与建议虽然大家可能经常用框架提供的api来实现深拷贝。 这篇文章分享的目的,更多还是希望用一篇文章整理清楚深浅拷贝的含义、递归实现思路,以及小伙伴们如果使用了JSON.parse()这种黑科技,一定要清楚这样写的优缺点。 5. 修正上面的deepCopy方法有漏洞，没有考虑source一开始就是数组的情况 下面是一个修改后版本 1234567891011function deepCopy( source ) &#123; let target = Array.isArray( source ) ? [] : &#123;&#125; for ( var k in source ) &#123; if ( typeof source[ k ] === &apos;object&apos; ) &#123; target[ k ] = deepCopy( source[ k ] ) &#125; else &#123; target[ k ] = source[ k ] &#125; &#125; return target&#125;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.shengkesi.cn/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.shengkesi.cn/tags/JavaScript/"}]},{"title":"前端工程师成长的痛，你占几条？","slug":"前端工程师成长的痛，你占几条？","date":"2019-02-23T01:48:01.000Z","updated":"2019-03-04T08:04:24.000Z","comments":true,"path":"前端工程师成长的痛，你占几条？/","link":"","permalink":"https://www.shengkesi.cn/前端工程师成长的痛，你占几条？/","excerpt":"原文链接作者：真传Xhttps://mp.weixin.qq.com/s?__biz=MzAxODE2MjM1MA==&amp;mid=2651555898&amp;idx=1&amp;sn=1a523de9728c65c03bc851620a06240e 引言对于很多前端工程师，很容易进入工作的舒适区，该熟悉的业务已熟悉了，然后就是重复用轮子，这样很容易让自己的成长处于原地打转以及低水平重复的状态。 去年11月，我们累计交流了203人（1-3年的前端工程师，遇到职业瓶颈），有的是主观原因造成的 ，有的是客观原因造成的，本文从客观跟主观两方面进行了总结，帮助大家 自检 。","text":"原文链接作者：真传Xhttps://mp.weixin.qq.com/s?__biz=MzAxODE2MjM1MA==&amp;mid=2651555898&amp;idx=1&amp;sn=1a523de9728c65c03bc851620a06240e 引言对于很多前端工程师，很容易进入工作的舒适区，该熟悉的业务已熟悉了，然后就是重复用轮子，这样很容易让自己的成长处于原地打转以及低水平重复的状态。 去年11月，我们累计交流了203人（1-3年的前端工程师，遇到职业瓶颈），有的是主观原因造成的 ，有的是客观原因造成的，本文从客观跟主观两方面进行了总结，帮助大家 自检 。 一、客观原因 没有经过系统的计算机学科学习导致计算机功底不扎实 这种问题主要出现在以下三类小伙伴身上： （1）计算机科班出身，但是在校期间基础不扎实。 （2）非计算机科班，通过自学，但不够系统，所学不成体系。 （3）非计算机科班，通过0基础的培训班，短时间速成，不够扎实。 因工作环境环境限制，导致成长性不足 以上客观主要导致问题表现如下： 因一些基础算法、数据结构理论不扎实导致一些编程思维难于理解。 比如 原型链，如果清楚 数据结构中链表结构，那么这个东西不难理解，再比如 哈希值，懂得数据结构中哈希表，哈希值也就迎刃而解。 计算机体系结构、操作系统理论、网络理论不扎实导致到后期一些东西难于理解。 比如有同学从前端学习入手，后来学习node开发 ，在 I/O ,进程、线程、IPC 、线程锁方面有些概念就比较难于理解，而导致不能很好得使用node 的api 。 工作业务型驱动，重复低水平劳动，基本上工作第一年对前端开发已经比较熟悉了，每天做表层业务模块，重复做已经会的东西，技术深度没有成长。 工作环境中无高手，前端开发团队大家水平相当，没有高手能够指导自己进入下一个层次。 二、主观原因 没有意识建立自己的底层系统 前端整体体系架构没有做过深入思考，导致用会用，但不知道为什么用，用另外一个有什么区别。 个人行动力不足，没有针对性的刻意练习 （1）有意识但是没有行动，比如网盘收集了一堆资料或者一堆视频，然后就没有然后了。 （2）自律性不足，很容易被外界影响，导致时间碎片化。 三、提升路径 学习东西，自学是一种途径，然而在自学的过程中，很多人处于不知道自己不知道的状态，无监督 ，非常容易放弃。 另一种是跟着高手，开阔视野，达到 知道自己不知道的境界，从而有方向，在短时期内进入到一个新的境界，节约时间成本，借助外力突破瓶颈。 @真传Xmp.weixin.qq.com/s?__biz=MzAxODE2MjM1MA==&mid=2651555898&idx=1&sn=1a523de9728c65c03bc851620a06240e","categories":[{"name":"随笔","slug":"随笔","permalink":"https://www.shengkesi.cn/categories/随笔/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://www.shengkesi.cn/tags/随笔/"}]},{"title":"Hexo-主题文件夹上传不到自己的github上","slug":"Hexo-主题文件夹上传不到自己的github上","date":"2019-02-10T06:44:49.000Z","updated":"2019-03-01T02:27:32.000Z","comments":true,"path":"Hexo-主题文件夹上传不到自己的github上/","link":"","permalink":"https://www.shengkesi.cn/Hexo-主题文件夹上传不到自己的github上/","excerpt":"引言好多人都已经用Hexo博客框架搭建了自己的博客，而且也部署到了自己的github上（或者是自己的云服务器上），再简单购买一个域名，让别人也可浏览自己的博客。但是搭建过程中遇到了好多坑，自己的博客代码上传至自己的github上，但是发现除了主题文件夹下的文件，其他都 push 上去了 而自己本地的主题文件夹是有文件的 探索大家可能想到是因为.gitignore里面忽略了这两个文件夹下的所有文件，但是经过自己的检查，发现并不是这儿的问题，自己的项目的.gitignore内容如下：","text":"引言好多人都已经用Hexo博客框架搭建了自己的博客，而且也部署到了自己的github上（或者是自己的云服务器上），再简单购买一个域名，让别人也可浏览自己的博客。但是搭建过程中遇到了好多坑，自己的博客代码上传至自己的github上，但是发现除了主题文件夹下的文件，其他都 push 上去了 而自己本地的主题文件夹是有文件的 探索大家可能想到是因为.gitignore里面忽略了这两个文件夹下的所有文件，但是经过自己的检查，发现并不是这儿的问题，自己的项目的.gitignore内容如下： 真正的解决办法经过多番探索，终于找到了症结，先来说如何解决 凡是通过git clone从github上拉取的代码，删除除了项目根目录以外的任何位置的 .git文件夹，.gitignore (或者编辑这个文件夹，删除那些你想上传但是被忽略的文件或文件夹) 和 .github 文件夹 操作完成之后，用SourceTree还是看不到需要上传的主题文件在“未暂存文件”一栏中，不要失望接着往下看 还要删除掉 SourceTree 中的 主题 子模块 ，如下图： 删除时，一定要勾选 “强制删除” ，要不然会删除不掉，而且SourceTree报错 出现此问题的原因主要根源是每次我们下载主题时，都会用git命令clone源代码，例如像这样： 1$ git clone --branch v5.1.2 https://github.com/iissnan/hexo-theme-next themes/next 最终导致自己的主题文件夹下多了个.git文件夹，会被认为是另一个资源库，从属于自己的项目之下，在SourceTree中显示成“子模块”，而这些项目需要的主题文件不会被push到自己的github仓库中。","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://www.shengkesi.cn/categories/Hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://www.shengkesi.cn/tags/hexo/"}]},{"title":"Hexo 插入图片","slug":"Hexo-插入图片","date":"2019-02-09T06:13:18.000Z","updated":"2019-03-01T02:27:32.000Z","comments":true,"path":"Hexo-插入图片/","link":"","permalink":"https://www.shengkesi.cn/Hexo-插入图片/","excerpt":"引言图片资源放在本地 source/ 文件夹后，本地服务器浏览时图片正常显示，但部署到 github 上会找不到图片。 究其原因，是图片路径出现问题。开始时自己在 source/ 文件夹下建了 assets 文件夹，专门用于存放文章相关的图片： 12345source |- _posts |- assets |- images |- image-1.png 使用 markdown 引用图片的方式为 1![hexo image](../../assets/images/image-1.png) 查看结构，发现部署以后，图片会自动添加日期相关的文件结构目录： 而实际存放的目录是 http://www.shengkesi.cn/assets/images/image-1.png ，导致图片资源访问不到。 为了解决这个问题查了很多资料，才知道原来除了本地存放图片，还可以使用图床。","text":"引言图片资源放在本地 source/ 文件夹后，本地服务器浏览时图片正常显示，但部署到 github 上会找不到图片。 究其原因，是图片路径出现问题。开始时自己在 source/ 文件夹下建了 assets 文件夹，专门用于存放文章相关的图片： 12345source |- _posts |- assets |- images |- image-1.png 使用 markdown 引用图片的方式为 1![hexo image](../../assets/images/image-1.png) 查看结构，发现部署以后，图片会自动添加日期相关的文件结构目录： 而实际存放的目录是 http://www.shengkesi.cn/assets/images/image-1.png ，导致图片资源访问不到。 为了解决这个问题查了很多资料，才知道原来除了本地存放图片，还可以使用图床。 图床所谓图床，就是储存图片的服务器，支持创建图片的对外链接地址便于引用。使用时只要引入图片的绝对地址就可以，方便简单。 图床分为免费和收费的。无论是国内还是国外的免费图床都存在隐患，毕竟小本买卖，一旦停止服务，图片自然也就变成了小红叉。收费图床稳定一些，不管从服务还是稳定性上，都更推荐收费图床。 目前大家推荐比较多的国内图床： 七牛云储存新注册用户可免费使用 10G 存储空间。 极简图床其实也是依赖七牛云储存账号的。 本地图片在本地存放图片的方法经过修改以后也可以完美使用。重点在于 _config.yml 文件中设置 post_asset_folder: true，开启资源文件夹功能，该功能支持用户通过相对路径标签引用资源。 下面我们来看会发生什么。执行 hexo new [layout] [title]创建一篇新的文章，会发现 source/_posts 下自动生成了一个和 md 文件同名的目录（也可以自己手动创建），这就是用于存放与文章有关的图片文件夹。 例如，我们想写一篇名为 hexo.md 的文章，执行 hexo new “hexo”，那么 _post 文件夹下的结构将是： 123_posts |- hexo.md |_ hexo 将相关的图片放入 hexo 文件夹 1234_posts |- hexo.md |_ hexo |_ image-2.png 需要注意的是，使用该种方式在 markdown 文件中引用图片将不再使用 markdown 语法，而是使用标签插件引用相对路径，否则可能造成图片和其他资源显示不正确。引用语法如下： 123&#123;% asset_path slug %&#125;&#123;% asset_img slug [title] %&#125;&#123;% asset_link slug [title] %&#125; 在上述语法下，插入图片的方法： 1&#123;% asset_img image-2.png This is an example image %&#125; 查看页面，发现图片已经可以正常显示了，图片的路径和实际存放目录是一致的。 如果想使用 markdown 语法插入相对路径的图片，可以利用插件。设置 post_asset_folder:true 后，在根目录下执行： 1npm install https://github.com/CodeFalling/hexo-asset-image --save 确保在 source/_posts 下创建和 markdown 文件同名的目录，里面存放需要的图片，然后在 markdown 中插入图片： 1! [hexo image] (hexo/image-1.png) 生成的页面中图片引用路径 1&lt;img src=&quot;/2019/02/10/hexo/image-1.png&quot; alt=&quot;hexo image&quot;&gt; 至此，用 markdown 完美实现本地图片插入。 参考文档：https://hexo.io/zh-cn/docs/asset-folders.html","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://www.shengkesi.cn/categories/Hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://www.shengkesi.cn/tags/hexo/"}]},{"title":"vue指令中寻找元素parentNode为null的问题（指令中钩子函数的运用）","slug":"vue指令中寻找元素parentNode为null的问题（指令中钩子函数的运用）","date":"2019-01-23T04:20:59.000Z","updated":"2019-03-01T02:27:32.000Z","comments":true,"path":"vue指令中寻找元素parentNode为null的问题（指令中钩子函数的运用）/","link":"","permalink":"https://www.shengkesi.cn/vue指令中寻找元素parentNode为null的问题（指令中钩子函数的运用）/","excerpt":"引语在VUE中运用 VUE 指令，发现之前的写法存在问题，刷新页面后报错，先贴代码， 再看报错 12345678// 权限指令Vue.directive('has', &#123; bind: function (el, binding) &#123; if (el.parentNode &amp;&amp; !Vue.prototype.$_has(binding.value)) &#123; el.parentNode.removeChild(el) &#125; &#125;&#125;) 只要刷新页面会出现如下问题：","text":"引语在VUE中运用 VUE 指令，发现之前的写法存在问题，刷新页面后报错，先贴代码， 再看报错 12345678// 权限指令Vue.directive('has', &#123; bind: function (el, binding) &#123; if (el.parentNode &amp;&amp; !Vue.prototype.$_has(binding.value)) &#123; el.parentNode.removeChild(el) &#125; &#125;&#125;) 只要刷新页面会出现如下问题： 猜测并寻找出现报错的原因看到这样的报错就顺藤摸瓜到这个VUE指令中，初步猜想是 函数中 el 元素未找到，但实际则是 el 元素的父节点 el.parentNode 未找到，值为 null，于是写如下代码验证自己的猜测 123456789101112// 权限指令Vue.directive('has', &#123; bind: function (el, binding) &#123; console.log(el.parentNode) if (el.parentNode &amp;&amp; !Vue.prototype.$_has(binding.value)) &#123; el.parentNode.removeChild(el) &#125; setTimeout(() =&gt; &#123; console.log(el.parentNode) &#125;, 2000) &#125;&#125;) 结果是这样的： 进而验证了我的猜测 寻找解决方案经过百度查阅资料，终于恍然大悟，这篇文章说到点上了vue指令与$nextTick 操作DOM的不同之处或许这篇文章跟我要解决的不是一个问题，但是已经写的很明了，把关键的地方摘抄到这： vue指令钩子函数 一个指令定义对象可以提供如下几个钩子函数 (均为可选)： bind：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。 inserted：被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)。 update：所在组件的 VNode 更新时调用，但是可能发生在其子 VNode 更新之前。指令的值可能发生了改变，也可能没有。但是你可以通过比较更新前后的值来忽略不必要的模板更新 (详细的钩子函数参数见下)。 componentUpdated：指令所在组件的 VNode 及其子 VNode 全部更新后调用。 unbind：只调用一次，指令与元素解绑时调用。 最为关键的一句，解决问题的关键inserted：被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)。 更改后的代码为12345678// 权限指令Vue.directive('has', &#123; inserted: function (el, binding) &#123; if (el.parentNode &amp;&amp; !Vue.prototype.$_has(binding.value)) &#123; el.parentNode.removeChild(el) &#125; &#125;&#125;) 总结：如果当前节点刚刚被建立,还没有被插入到DOM树中,则该节点的parentNode属性会返回null. 此时，完美解决问题。所以在用任何东西之前都熟读文档是很有必要的，免得出现问题像我这样绕一大圈","categories":[{"name":"Vue","slug":"Vue","permalink":"https://www.shengkesi.cn/categories/Vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://www.shengkesi.cn/tags/vue/"}]},{"title":"Axios 执行多个并发请求(使用Promise解决多层异步调用)","slug":"Axios-执行多个并发请求-promise","date":"2018-12-18T00:21:43.000Z","updated":"2019-03-01T02:27:32.000Z","comments":true,"path":"Axios-执行多个并发请求-promise/","link":"","permalink":"https://www.shengkesi.cn/Axios-执行多个并发请求-promise/","excerpt":"引语场景：工作中遇到一个数据接口同时依赖于另外两个接口的情况,需要两个接口返回的数据才能实现进一步操作，下面介绍 3 种方法 利用js回调嵌套的方式1234567891011121314151617181920212223242526// 异步接口1: 科室列表function getDepartmentsList(callback)&#123; //模拟实现 var departmentList = Math.ceil(Math.random()*1000) setTimeout(function()&#123; callback(departmentList) &#125;,Math.random()*1000)&#125;// 异步接口2: 级别列表function getLevelList(callback)&#123; //模拟实现 var levelList = Math.ceil(Math.random()*1000)+1000 setTimeout(function()&#123; callback(levelList) &#125;,Math.random()*1000)&#125;//异步接口，列表中科室和级别码转换成对应的中文，需要前两个接口的数据function registrationList(departmentList,levelList,callback)&#123; //模拟实现 var percent = Math.ceil(departmentList/levelList*100) setTimeout(function()&#123; callback(percent) &#125;,Math.random()*1000)&#125;","text":"引语场景：工作中遇到一个数据接口同时依赖于另外两个接口的情况,需要两个接口返回的数据才能实现进一步操作，下面介绍 3 种方法 利用js回调嵌套的方式1234567891011121314151617181920212223242526// 异步接口1: 科室列表function getDepartmentsList(callback)&#123; //模拟实现 var departmentList = Math.ceil(Math.random()*1000) setTimeout(function()&#123; callback(departmentList) &#125;,Math.random()*1000)&#125;// 异步接口2: 级别列表function getLevelList(callback)&#123; //模拟实现 var levelList = Math.ceil(Math.random()*1000)+1000 setTimeout(function()&#123; callback(levelList) &#125;,Math.random()*1000)&#125;//异步接口，列表中科室和级别码转换成对应的中文，需要前两个接口的数据function registrationList(departmentList,levelList,callback)&#123; //模拟实现 var percent = Math.ceil(departmentList/levelList*100) setTimeout(function()&#123; callback(percent) &#125;,Math.random()*1000)&#125; 利用es6的promise解决回调地狱问题《ES6标准入门》对Promise的描述所谓Promise，就是一个对象，用来传递异步操作的消息。它代表了某个未来才会知道的结果的事件（通常是一个异步操作），并且这个事件提供统一的API，可供进一步处理。 MDN对Promise的描述：Promise 对象是一个代理对象（代理一个值），被代理的值在Promise对象创建时可能是未知的。它允许你为异步操作的成功和失败分别绑定相应的处理方法（handlers）。 这让异步方法可以像同步方法那样返回值，但并不是立即返回最终执行结果，而是一个能代表未来出现的结果的promise对象 当时看到Promise最头疼的，就是初学者看起来匪夷所思，也是最被js程序员广为称道的特性：then函数调用链。then函数调用链，从其本质上而言，就是对多个异步过程的依次调用，本文就从这一点着手，对Promise这一特性进行研究和学习。Promise的相关知识，请参阅 Promise的链式调用 基于以上对Promise的了解，我们知道可以使用它来解决多层回调嵌套后的代码蠢笨难以维护的问题。下面请看具体代码： 每个异步接口 返回一个promise对象123456789101112131415161718192021222324252627282930// 异步接口1: 科室列表function getDepartmentsList()&#123; //模拟 return new Promise(function(resolve,reject)&#123; var departmentList = Math.ceil(Math.random()*1000) setTimeout(function()&#123; resolve(departmentList) &#125;,Math.random()*1000) &#125;) &#125;// 异步接口2: 级别列表function getLevelList()&#123; return new Promise(function(resolve,reject)&#123; var levelList = Math.ceil(Math.random()*1000)+1000 setTimeout(function()&#123; resolve(levelList) &#125;,Math.random()*1000) &#125;) &#125;// 异步接口, 列表中科室和级别码转换成对应的中文，需要前两个接口的数据function registrationList(departmentList,levelList)&#123; return new Promise(function(resolve,reject)&#123; var percent = Math.ceil(departmentList/levelList*100) setTimeout(function()&#123; resolve(percent) &#125;,Math.random()*1000) &#125;)&#125; 利用promise.all方法保证接口数据成功返回再执行操作123456Promise.all([getDepartmentsList(),getLevelList()]).then(function([departmentList,levelList])&#123; //这里写等这两个ajax都成功返回数据才执行的业务逻辑 registrationList(departmentList,levelList).then(function(percent)&#123; console.log(percent) &#125;)&#125;) Axios 解决方案(VUE)每个异步接口 返回一个axios对象12345678// 异步接口1: 科室列表getDepartmentsList () &#123; return axios.get(process.env.BASE_API_WAP + 'category/2');&#125;,// 异步接口2: 级别列表getLevelList () &#123; return axios.get(process.env.BASE_API_WAP + 'category/3');&#125; 利用axios.all方法执行多个并发请求1234567891011121314151617181920212223242526272829303132333435363738394041// 过滤数据函数filterData (targetArray) &#123; targetArray.forEach(item =&gt; &#123; for (let key in this.departmentsList) &#123; if (Number(item.departments) === this.departmentsList[key].id) &#123; item.departments = this.departmentsList[key].name; &#125; &#125; for (let key in this.levelList) &#123; if (Number(item.level) === this.levelList[key].id) &#123; item.level = this.levelList[key].name; &#125; &#125; &#125;);&#125;// 初始化init () &#123; this.title = ''; registrationList(this.current, this.pageSize, this.title).then(data =&gt; &#123; this.data = data.content; // 过滤数据 this.filterData(this.data); this.totalSize = data.total; this.pages = data.pages; &#125;).catch(error =&gt; &#123; console.log(error); &#125;);&#125;mounted () &#123; // 执行多个并发请求, 列表中科室和级别码转换成对应的中文，需要前两个接口的数据 let _this = this; axios.all([this.getDepartmentsList(), this.getLevelList()]) .then(axios.spread(function (list1, list2) &#123; _this.departmentsList = list1.data; _this.levelList = list2.data; // 两个请求现在都执行完成 _this.init(); &#125;));&#125; 总结 前端解决异步的问题时常都会遇到，Promise给前端程序员带来了新的解决思路，在它基础之上的promise的工具库（如Axios），也是在此上的封装。只要明白了其中的原理，在什么开发框架下都能灵活运用。","categories":[{"name":"Promise","slug":"Promise","permalink":"https://www.shengkesi.cn/categories/Promise/"}],"tags":[{"name":"promise","slug":"promise","permalink":"https://www.shengkesi.cn/tags/promise/"},{"name":"axios","slug":"axios","permalink":"https://www.shengkesi.cn/tags/axios/"},{"name":"ES6","slug":"ES6","permalink":"https://www.shengkesi.cn/tags/ES6/"},{"name":"回调地狱","slug":"回调地狱","permalink":"https://www.shengkesi.cn/tags/回调地狱/"}]},{"title":"你真的会检查自己系统安装的VUE版本吗？","slug":"你真的会检查自己系统安装的VUE版本吗？","date":"2018-12-17T05:55:52.000Z","updated":"2019-03-01T02:27:32.000Z","comments":true,"path":"你真的会检查自己系统安装的VUE版本吗？/","link":"","permalink":"https://www.shengkesi.cn/你真的会检查自己系统安装的VUE版本吗？/","excerpt":"引语或许你觉得我这篇文章写的很傻，和无聊，但是我跟你说，即使你从事VUE开发一段时间，也不见得求在一些小问题上所求甚解。 有些人认为的VUE版本检查命令是：1vue -V 或者1vue --version 如下图","text":"引语或许你觉得我这篇文章写的很傻，和无聊，但是我跟你说，即使你从事VUE开发一段时间，也不见得求在一些小问题上所求甚解。 有些人认为的VUE版本检查命令是：1vue -V 或者1vue --version 如下图 其实你们大错特错这哪里是检查VUE版本的，那是vue-cli的版本，vue-cli是搭vue框架的脚手架，是vue的生态环境之一 检查自己项目的VUE版本项目根目录下 package.json 中的VUE版本为安装依赖的最低支持版本，例如: “VUE”: “^2.5.13”, 要想项目运行正常，安装的VUE版本最低为 2.5.13如果要检查VUE版本，需要到node_modules中vue文件夹下的package.json中查找，或者是任意一个文件的头部注释 总结现在就目前而言，vue-cli已经进入3.0时代，与2.0的脚手架使用差别有些大了，项目构建初期的选择性更灵活了，比如 PWA ，目前VUE版本还在2.0时代，据说VUE3.0就快出来了，很期待。","categories":[{"name":"Vue","slug":"Vue","permalink":"https://www.shengkesi.cn/categories/Vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://www.shengkesi.cn/tags/vue/"}]},{"title":"element-ui table展开行，设置type=\"expand\"，如何添加表头？如何去掉展开按钮并设置成文字？","slug":"element","date":"2018-09-27T15:08:37.000Z","updated":"2019-03-01T02:27:32.000Z","comments":true,"path":"element/","link":"","permalink":"https://www.shengkesi.cn/element/","excerpt":"","text":"解决方案从项目的可维护和可扩展性考虑，还是改 element-ui 的源码，是最好的解决方案。添加了了一个属性 look, 更改了展开行中的图标 ＞，如下图 表头 label 属性，源码本身就支持，用就可以了用的时候这样用,如下:改变了之后，变为文字，如下图 用法12&lt;el-table-column label=\"操作\" type=\"expand\" look=\"查看\"&gt;&lt;/el-table-column&gt; 源代码文件夹替换替换将修改后的 lib 文件夹 替换掉你的 element-ui 中的 lib 文件夹, 路径：node-modules/element-ui点击下载","categories":[{"name":"Element-UI","slug":"Element-UI","permalink":"https://www.shengkesi.cn/categories/Element-UI/"}],"tags":[{"name":"element-ui","slug":"element-ui","permalink":"https://www.shengkesi.cn/tags/element-ui/"}]},{"title":"VUE的权限控制","slug":"VUE的权限控制","date":"2018-08-22T07:17:06.000Z","updated":"2019-03-04T08:04:24.000Z","comments":true,"path":"VUE的权限控制/","link":"","permalink":"https://www.shengkesi.cn/VUE的权限控制/","excerpt":"概述如果VUE权限控制问题困扰着你，那么这篇文章将拯救你。关于VUE的前台路由控制和视图控制是大家最需要的前端技术解决方案。 Vue-Access-Control本解决方案是基于 Vue-Access-Control 进行改造的，深度剖析了里面的路由控制和视图控制（资源控制还是后台做比较靠谱） 心路历程 权限数据由后台接口获得（权限树），但是前端不能贸然存储到本地浏览器里（localStorage、sessionStorage、Cookie等），如果被恶意篡改，麻烦可就大了!!!!! 想要用 VUEX （状态管理模式）来存储，但是网页一刷新，就会被重置成空，所以我推断 VUEX 适合用在 “无刷新” 的 APP 中；再者，权限树这么复杂的结构，并不是 VUEX 所实现的 “共享状态” 模式，只是单一的对每个页面（路由控制）、按钮（视图控制）、接口（请求控制） 针对实际的应用场景，请求控制，就是某个角色是否有调用某个接口的权限，这种后台会做权限控制的，没有权限会给你报401的，只有“路由控制”和“视图控制”是前端人员需要去解决的。 对于 Vue-Access-Control 这套权限解决方案貌似也有不完美之处，不能贴合实际的开发需要，需要稍作调整，比如路由嵌套两层还是可以使用的，要是三层及其以上就得修改递归的函数了。","text":"概述如果VUE权限控制问题困扰着你，那么这篇文章将拯救你。关于VUE的前台路由控制和视图控制是大家最需要的前端技术解决方案。 Vue-Access-Control本解决方案是基于 Vue-Access-Control 进行改造的，深度剖析了里面的路由控制和视图控制（资源控制还是后台做比较靠谱） 心路历程 权限数据由后台接口获得（权限树），但是前端不能贸然存储到本地浏览器里（localStorage、sessionStorage、Cookie等），如果被恶意篡改，麻烦可就大了!!!!! 想要用 VUEX （状态管理模式）来存储，但是网页一刷新，就会被重置成空，所以我推断 VUEX 适合用在 “无刷新” 的 APP 中；再者，权限树这么复杂的结构，并不是 VUEX 所实现的 “共享状态” 模式，只是单一的对每个页面（路由控制）、按钮（视图控制）、接口（请求控制） 针对实际的应用场景，请求控制，就是某个角色是否有调用某个接口的权限，这种后台会做权限控制的，没有权限会给你报401的，只有“路由控制”和“视图控制”是前端人员需要去解决的。 对于 Vue-Access-Control 这套权限解决方案貌似也有不完美之处，不能贴合实际的开发需要，需要稍作调整，比如路由嵌套两层还是可以使用的，要是三层及其以上就得修改递归的函数了。 实现原理详见Vue-Access-Control 具体实现授之以鱼不如授之以渔 本着这个原则，代码的主要设计思想是： 将接口所得数据（菜单树形结构）存至本地(sessionStorage); 每次刷新页面重新调取接口，更新数据到本地(sessionStorage)，保证设置权限的实时效应; 其次是用VUEX的状态机管理机制，由于父子组件相互调用问题，会导致数据不能及时从父组件更新到子组件的视图上，就是不显示在页面上；故而用VUEX来更新数据，让其获取到全局性质的值，这种设计来源于同事遇到的这个坑。 App.vue123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139&lt;template&gt; &lt;div id=\"app\" class=\"app-main\"&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import Vue from 'vue'import &#123;getBankAuth&#125; from '@/api/auth'import userPath from '@/router/fullpath'import * as util from '@/utils/util.js'export default &#123; name: 'App', data () &#123; return &#123; menuData: null, // 导航树 userAuth: null // 接口返回权限数据 &#125; &#125;, methods: &#123; getRoutes (userAuth) &#123; if (!userAuth[0].children) &#123; return console.warn(userAuth) &#125; let allowedRouter = [] // 将菜单数据转成多维数组格式 let arrayMenus = util.buildMenu(userAuth[0].children) // 将多维数组转成对象格式 let hashMenus = &#123;&#125; hashMenus = util.getPath(arrayMenus) // 全局挂载hashMenus，用于实现路由守卫 this.$root.hashMenus = hashMenus // 筛选本地路由方法 let findLocalRoute = function (array, base) &#123; let replyResult = [] array.forEach(function (route) &#123; let pathKey = (base ? base + '/' : '') + route.path if (hashMenus.hasOwnProperty(pathKey)) &#123; if (Object.prototype.toString.call(route.children) === '[object Array]') &#123; route.children = findLocalRoute(route.children, pathKey) &#125; replyResult.push(route) &#125; &#125;) if (base) &#123; return replyResult &#125; else &#123; allowedRouter = allowedRouter.concat(replyResult) &#125; &#125; let originPath = util.deepcopy(userPath) findLocalRoute(originPath) return allowedRouter &#125;, extendRoutes (allowedRouter) &#123; let vm = this let actualRouter = util.deepcopy(allowedRouter) actualRouter.map(e =&gt; &#123; // 复制子菜单信息到meta用于实现导航相关效果，非必需 if (e.children) &#123; if (!e.meta) e.meta = &#123;&#125; e.meta.children = e.children &#125; // 为动态路由添加独享守卫 return e.beforeEnter = function (to, from, next) &#123; if (vm.$root.hashMenus[to.path]) &#123; next() // 按钮权限检验方法 Vue.prototype.$_has = function (p) &#123; let permission = false // 校验权限 this.hashButtons.forEach(item =&gt; &#123; if (item.hasOwnProperty(to.path)) &#123; if (item[to.path].indexOf(p) !== -1) &#123; permission = true &#125; &#125; &#125;) return permission &#125; &#125; else &#123; next('/401') &#125; &#125; &#125;) // let originPath = util.deepcopy(userPath) let originPath = actualRouter // 注入路由 vm.$router.addRoutes(originPath.concat([&#123; path: '*', redirect: '/login' &#125;])) &#125;, // 获取权限数据 getAuthority (role) &#123; let vm = this // 检查登录状态 let localUser = util.session('token') if (!localUser || !localUser.authorities) &#123; return vm.$router.push(&#123; path: '/login', query: &#123; from: vm.$router.currentRoute.path &#125; &#125;) &#125; if (role === 'bank') &#123; getBankAuth().then(data =&gt; &#123; let userAuth = data // 获得实际路由 let allowedRouter = vm.getRoutes(userAuth) // 若无可用路由限制访问 if (!allowedRouter || !allowedRouter.length) &#123; util.session('token', '') return document.body.innerHTML = ('&lt;h1&gt;账号访问受限，请联系系统管理员！&lt;/h1&gt;') &#125; // 动态注入路由 vm.extendRoutes(allowedRouter) // 保存数据用作他处，非必需 vm.menuData = allowedRouter vm.userAuth = userAuth &#125;).catch(error =&gt; &#123; console.log(error) &#125;) &#125; &#125; &#125;, created () &#123; this.getAuthority('bank') &#125;&#125;&lt;/script&gt;&lt;style lang=\"scss\"&gt; @import 'assets/sass/sks.scss'; @import 'assets/fonts/iconfont.css';/*阿里字体图标*/ @import 'assets/sass/table.scss';/*table样式*/ @import 'assets/sass/dialog.scss'; /* dialog样式 */ .app-main &#123; width: 100%; height: 100%; overflow: auto; &#125;&lt;/style&gt; 代码剖析Layout.vue1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950export default &#123; name: 'layout', created () &#123; this.getNav() &#125;, methods: &#123; getNav () &#123; // 设置导航 let menus = this.$parent.menuData if (!localStorage.navBankArray) &#123; if (menus) &#123; // 整理导航数据结构 menus.forEach((item, index) =&gt; &#123; if (index === 0) &#123; menus[index].active = true &#125; else &#123; menus[index].active = false &#125; &#125;) this.routerMap = menus localStorage.navBankArray = JSON.stringify(menus) &#125; &#125; else &#123; let tempBankArray = JSON.parse(localStorage.navBankArray) this.routerMap = tempBankArray &#125; &#125;, logout () &#123; // 清除session util.session('token', '') // 清除菜单权限 this.$root.hashMenus = &#123;&#125; // 退出登录 logoutBank() .then(res =&gt; &#123; store.commit('logout', this) this.$router.replace(&#123;name: 'Login'&#125;) localStorage.removeItem('navBankArray') &#125;) .catch(error =&gt; &#123; console.log(error) &#125;) &#125; &#125;, watch: &#123; $route () &#123; this.getNav() &#125; &#125;&#125;","categories":[{"name":"Vue","slug":"Vue","permalink":"https://www.shengkesi.cn/categories/Vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://www.shengkesi.cn/tags/vue/"},{"name":"permission","slug":"permission","permalink":"https://www.shengkesi.cn/tags/permission/"}]},{"title":"Hello World","slug":"hello-world","date":"2018-08-21T07:17:06.000Z","updated":"2019-03-01T02:27:32.000Z","comments":true,"path":"hello-world/","link":"","permalink":"https://www.shengkesi.cn/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://www.shengkesi.cn/categories/Hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://www.shengkesi.cn/tags/hexo/"}]}]}