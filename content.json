{"meta":{"title":"sanks的博客","subtitle":"用新思路解决旧问题！","description":"对于JavaScript(ES6)、VUE、NodeJS、等相关技术的实战经验分享","author":"sanks","url":"https://www.shengkesi.cn"},"pages":[{"title":"Page not found","date":"2020-04-15T06:41:36.950Z","updated":"2019-03-01T02:27:32.000Z","comments":false,"path":"/404.html","permalink":"https://www.shengkesi.cn//404.html","excerpt":"","text":""},{"title":"sanks简介","date":"2018-09-17T00:46:50.000Z","updated":"2020-04-25T17:00:57.065Z","comments":false,"path":"about/index.html","permalink":"https://www.shengkesi.cn/about/index.html","excerpt":"","text":"About me13年3月从事前端开发至今 现研究方向现研究flutter和Dart语法，socket.io 写个即时通信的小项目。项目还在努力维护中，为保证功能完善，给大家铺路。 20202020-01-10APP方面学习flutter和Dart语法，移动web继续使用VUE和ReactJS，并写一些nodejs相关的中间件或服务器。 2019自己决定重新调整自己在前端领域的发展方向，努力拓展自己未涉及的领域。 2019-05-04利用周六日的闲暇时间，填了搭建react + typescript 的一些坑，框架已经成型，项目中想到的，需要的配置都有了；好的前端框架搭建是做一个可维护，可拓展项目的基础，不会给以后接手的程序员带来麻烦。 2019-03-10几天的努力之下，自己的react项目总算成型，决定新建一个“发布”分支，以供以后开发用。 2019-03-04开始深入研究reactjs，弥补之前的浅尝辄止；一开始自己用官方的项目生成器生成了一个简单的架构，自己从这个简化版逐步加入babel, webpack, eslint 等相关的配置，有兴趣的朋友可以移步 react的基础之上进行引入webpack、eslint、babel的框架搭建, 但是你仔细阅读react项目下的 READEME.md, 你就会发现我绕了远路，其实react提供了 npm run eject 来注入webpack, eslint, label 等相关依赖和配置，可能这就是react给大家提供的 脚手架 吧，需要注意的是：这个命令只能执行一次，而且不可逆转。 2019-02-25为博客每篇文章（包括首页）也显示字数统计和阅读时长， Nginx 优化配置 - Gzip 压缩, 博文分享换成addthis。 2019-02-22为博客加入了百度统计功能，实际的去观察网站访问情况 2019-02-15为自己的博客网站进行了SEO，包括百度搜索和谷歌搜索，并加入了相关的站点地图，在hexo中添加百度主动推送功能, 每次部署主动推送一次 2019-02-09把自己的博客成功迁移到自己服务器上，配置了git远程资源库，配置nginx ：能够用https协议访问博客地址，强制http转https协议访问博客，http://shengkesi.cn -&gt; https://shengkesi.cn http://www.shengkesi.cn -&gt; https://www.shengkesi.cn 2019-01-27服务器部署gitlab失败后，自己在家测试了一下ping自己的博客的github地址，和ping自己的服务器对比了一下，发现github的延迟132ms,而且丢包；自己的服务器74ms，毅然决定把自己的博客网站迁移到自己的服务器上，一开始弄了FTP，但是有些舍近求远了；发现其实自己在服务器端搭建跟本地一样的开发环境即可，只是多了ngnix的安装和配置。 2019-01-25趁着工作午休时间，把自己博客的评论功能加上了，并填了首页插入的图片不显示的问题的坑。 2019-01-24经过折腾了linux安装docker, 并且在docker内装了jenkins后，感觉缺点什么，想弄个GitLab，在服务器存储自己的代码。踩坑开始，经过层层扒坑埋坑的过程，总算把GitLab建立起来了，但是访问是502页面。最后找到原因：由于服务配置太低（CPU 1核，内存2GB），无法满足Gitlab的（CPU 2核，内存4GB）的要求，页面报502，踩坑结束。 2018研究vue2.0 VUEX状态管理机制 webpack 等"},{"title":"archives","date":"2020-04-15T06:41:37.204Z","updated":"2019-03-01T02:27:32.000Z","comments":false,"path":"archives/index.html","permalink":"https://www.shengkesi.cn/archives/index.html","excerpt":"","text":""},{"title":"categories","date":"2020-04-15T06:41:37.322Z","updated":"2019-03-01T02:27:32.000Z","comments":false,"path":"categories/index.html","permalink":"https://www.shengkesi.cn/categories/index.html","excerpt":"","text":""},{"title":"","date":"2020-04-15T06:41:37.376Z","updated":"2019-03-01T02:27:32.000Z","comments":true,"path":"categories/package.json","permalink":"https://www.shengkesi.cn/categories/package.json","excerpt":"","text":"{\"dependencies\":{\"hexo-deployer-git\":\"^0.3.0\"}}"},{"title":"tags","date":"2020-04-15T06:41:37.469Z","updated":"2019-03-01T02:27:32.000Z","comments":false,"path":"tags/index.html","permalink":"https://www.shengkesi.cn/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"通过例子解释防抖动和节流","slug":"debounce-and-throttle","date":"2020-05-20T15:40:45.000Z","updated":"2020-06-02T11:33:57.949Z","comments":true,"path":"debounce-and-throttle/","link":"","permalink":"https://www.shengkesi.cn/debounce-and-throttle/","excerpt":"","text":"译文说明作者：David Corbacho原文链接：https://css-tricks.com/debouncing-throttling-explained-examples/ 引言以下是伦敦前端工程师 David Corbacho 的客座文章。我们已经之前讨论过这个主题，但是这次，David将通过交互式演示来讲解这些概念，使事情变得非常清楚。 Debounce 和 throttle 是两种类似(但不同的!)的技术，用于控制我们允许一个函数在一段时间内执行多少次。 在将函数附加到DOM事件时，具有函数的防抖动或节流的版本尤其有用。为什么呢?因为我们在事件和函数的执行之间给了自己一个控制层。请记住，我们不控制这些DOM事件的发出频率。它可以变化。 例如，让我们讨论一下滚动事件。看这个例子： See the Pen Scroll events counter by Corbacho (@dcorb) on CodePen. 当使用触控板、滚动轮或仅仅通过拖动滚动条滚动时，每秒可以轻松触发30个事件。但在我的测试中，在智能手机上缓慢滚动(调换)可能会每秒触发多达100个事件。您的滚动处理程序是否为这种执行速度做好了准备? 2011年，Twitter网站上出现了一个问题:当你向下滚动你的Twitter feed时，它变得缓慢和没有响应。John Resig发表了一篇关于这个问题的文章，文中解释了将开销大的函数直接附加到滚动事件是多么糟糕的想法。 John提出的解决方案(五年前)是在onScroll事件之外，每250ms运行一次循环。这样处理程序就不会耦合到事件。使用这个简单的技术，我们可以避免破坏用户体验。 如今，处理事件的方式稍微复杂了一些。让我来介绍一下Debounce, Throttle, 和requestAnimationFrame。我们还会看到匹配用例。 DebounceDebounce技术允许我们在一个调用中“分组”多个连续调用。 想象你在电梯里。门开始关上，突然另一个人试图上电梯，电梯没有开始它的功能去换楼层，门又开了。现在这种情况再次发生在另一个人身上。电梯推迟了它的功能(移动楼层)，但优化了它的资源。 你自己尝试一下。点击或移动按钮上方的鼠标: See the Pen Debounce. Trailing by Corbacho (@dcorb) on CodePen. 你可以看到连续快速的事件是如何由单个已删除的事件表示的。但如果这些事件是由巨大的差距引发的，那么 debouncing 就不会发生。 Leading edge (or “immediate”)你可能会发现，在触发函数执行之前，debouncing 事件会一直等待，直到如此快速的事件停止执行。为什么不立即触发函数执行，让它的行为就与原始的非debouncing 处理程序完全相同?除非快速调用暂停，否则不会激发处理函数。 你也可以这样做!下面是一个带着Leading标志的例子: 在 underscore.js 里，该选项被称为 immediate 而不是 leading 自己尝试一下吧: See the Pen Debounce. Leading by Corbacho (@dcorb) on CodePen. Debounce Implementations我第一次看到debounce在JavaScript中实现是在 2009年 John Hann 的文章中(他也创造了这个术语) 。 不久之后，Ben Alman创建了一个jQuery插件(不再维护)，一年后，Jeremy Ashkenas将其添加到underscore.js中。后来，它被添加到Lodash中， 完全替代了underscore。 3种实现在内部有点不同，但它们的接口几乎是相同的。 曾经有一段时间，underscore 从Lodash中采用了debounce/throttle实现，在2013年我在_.debounce函数中发现一个错误后，从那时起，这两种实现就分道扬镳了。 Lodash为它的 .debounce 和 .throttle 添加了更多的功能。原来的 immediate 标志被替换为leading 和 trailing 选项。你可以选择一个，或者两个都选。默认情况下，只启用了trailing 。 新的maxWait选项(目前只在Lodash中)不在本文中介绍，但它非常有用。实际上，正如您在lodash源代码中看到的，使用_.debounce和maxWait定义了throttle函数。 Debounce ExamplesResize Example在调整(桌面)浏览器窗口的大小时，它们可以在拖动“调整大小”操控时，会发出许多 resize 事件。 在这个演示中，自己尝试一下 See the Pen Debounce Resize Event Example by Corbacho (@dcorb) on CodePen. 如你所见，我们使用了resize事件的默认 trailing 选项，因为我们只对最终值感兴趣，即用户停止调整浏览器的大小之后。 在带有Ajax请求的自动完成表单中输入为什么要在用户仍在输入的情况下，每隔50毫秒向服务器发送一次Ajax请求呢? _.debounce可以帮助我们避免额外的工作，并且只在用户停止输入时发送请求。 在这里，把leading标志位打开是没有意义的。我们要等到最后一个字母打完。 See the Pen Debouncing keystrokes Example by Corbacho (@dcorb) on CodePen. 类似的用例是等待用户停止输入后再验证输入。“您的密码太短”类型的消息。 如何使用 debounce 和throttle，和常见的陷阱创建自己的debounce/throttle函数，或者从一些随机的博客文章中复制它，这可能很诱人。我的建议是直接使用underscore 或Lodash。如果你只需要 .debounce 和 .throttle函数，您可以使用Lodash自定义生成器来输出一个自定义的2KB缩小库。用这个简单的命令构建它: 12npm i -g lodash-clilodash include = debounce, throttle 也就是说，大多数人使用模块形式“lodash/throttle”和“lodash/debounce” 或“lodash”。或者带有“webpack/browserify/rollup” 的 “lodash/throttle” 和 “lodash.debounce” 软件包。 一个常见的陷阱是多次调用_.debounce函数： 1234567// WRONG$(window).on(&apos;scroll&apos;, function() &#123; _.debounce(doSomething, 300); &#125;);// RIGHT$(window).on(&apos;scroll&apos;, _.debounce(doSomething, 200)); 为debounce函数创建一个变量将允许我们调用私有方法debounced_version.cancel()，如果你需要它的话，该方法可在lodash和underscore.js中获得。 12345var debounced_version = _.debounce(doSomething, 200);$(window).on(&apos;scroll&apos;, debounced_version);// If you need itdebounced_version.cancel(); Throttle通过使用_.throttle，我们不允许函数每X毫秒执行一次以上。 这与debouncing 的主要区别是，throttle保证定期执行该函数，至少每X毫秒执行一次。 和debounce一样，throttle 技术也被Ben的plugin, underscore.js和lodash所涵盖。 Throttling 示例无限滚动一个很常见的例子。用户向下滚动无限滚动页面。您需要检查用户离底部有多远。如果用户接近底部，我们应该通过Ajax请求更多内容并将其附加到页面中。 在这里，我们热衷的 .debounce是没有用的。只有当用户停止滚动时才会触发。我们需要在用户到达底部之前开始获取内容。用.throttle我们可以保证我们不断地检查我们离底部有多远。 See the Pen Infinite scrolling throttled by Corbacho (@dcorb) on CodePen. requestAnimationFrame (rAF)requestAnimationFrame是另一种限速（rate-limiting）函数执行的方法。 它可以被认为是一个_.throttle(dosomething, 16)。但它的保真度要高得多，因为它是一个浏览器原生API，目标是更好的精确度。 我们可以使用rAF API，作为throttle 功能的替代，考虑到这些利弊: 利： 目标是60fps(16毫秒的帧)，但内部将决定如何安排渲染的最佳时间。 相当简单和标准的API，未来不会改变。更少的维护。 弊： rAFs的启动/取消是我们的责任，不像内部管理的.debounce或.throttle 如果浏览器选项卡不活动，它就不会执行。不过对于滚动、鼠标或键盘事件，这并不重要。 尽管所有的现代浏览器都支持rAF，但IE9、Opera Mini和老Android仍然不支持。时至今日，仍然[需要]我们增加(https://caniuse.com/#feat=requestanimationframe)[一个polyfill](https://www.paulirish.com/2011/requestanimationframe-for-smart-animating/) 。 node.js中不支持rAF。因此，你不能在服务器上使用它来控制文件系统事件。 根据经验，如果您的JavaScript函数是“绘制”或直接动画属性，我将使用requestAnimationFrame，在所有涉及重新计算元素位置的情况下使用它。 要发出Ajax请求，或者决定是否添加/删除一个类(这会触发CSS动画)，我将考虑.debounce或.throttle，您可以在这里设置更低的执行速率(例如，200ms，而不是16ms) 如果您认为rAF可以在underscore 或lodash中实现，那么它们都拒绝了这个想法，因为它是一个专门的用例，而且很容易直接调用。 Examples of rAF受Paul Lewis文章的启发，我将只讨论这个示例，以便在滚动中使用requestAnimation框架，在这篇文章中，他一步一步地解释了这个示例的逻辑。 在16ms的情况下，我将它和 _.throttle放在一起比较。提供类似的性能，但是rAF可能会在更复杂的场景中提供更好的结果。 See the Pen Scroll comparison requestAnimationFrame vs throttle by Corbacho (@dcorb) on CodePen. 我在headroom.js库中看到过这种技术的更高级的例子。在这里，逻辑被解耦并封装在一个对象中。 总结使用debounce、throttle和requestAnimationFrame来优化事件处理程序。每种技术略有不同，但这三种技术都是有用的，并且相互补充。 概括的说： debounce： 将突然发生的一系列事件(如击键)组合成一个事件。 throttle: 保证每X毫秒执行一次。比如每隔200毫秒检查一次滚动位置，以触发CSS动画。 requestAnimationFrame: 一个节流的选择。当你的函数在屏幕上重新计算和渲染元素，你想要保证平滑的变化或动画。注意:不支持IE9。 个人补充：防抖动（debounce）：所谓的抖动就是浏览器频繁布局时，由于算力不足导致的页面颤动现象。防抖动就是利用类似于节流的手段——无视短时间内重复回调，避免浏览器发生抖动现象的技术。 比较常见的抖动场景是在 auto index 的搜索设计上；当我们在搜索框内输入不同索引时，页面会频繁计算索引并渲染列表，以致产生抖动。但事实上在这类场景里，有价值的请求只会发生在用户停止输入后，通俗来说就是用户输入过程中的字符串不必当真。 节流（throttle）：节流指的都是某个函数在一定时间间隔内只执行第一次回调。 总结：前端常用的节流和防抖动技术，他们是 JS 闭包和高阶函数的现实应用。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.shengkesi.cn/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.shengkesi.cn/tags/JavaScript/"}]},{"title":"http request timeout","slug":"http-request-timeout","date":"2020-04-13T01:24:58.000Z","updated":"2020-06-02T11:33:58.118Z","comments":true,"path":"http-request-timeout/","link":"","permalink":"https://www.shengkesi.cn/http-request-timeout/","excerpt":"引语鉴于之前axios版本升级，去掉了baseUrl配置的问题，前端对于axios库的升级未做版本固定，导致项目启动报错；除了写成固定版本，还可以自己写一套请求响应机制。","text":"引语鉴于之前axios版本升级，去掉了baseUrl配置的问题，前端对于axios库的升级未做版本固定，导致项目启动报错；除了写成固定版本，还可以自己写一套请求响应机制。 方法一：Promise.race(timeout, request)顾名思义，Promse.race就是赛跑的意思，意思就是说，Promise.race([p1, p2, p3])里面哪个结果获得的快，就返回那个结果，不管结果本身是成功状态还是失败状态。 流程图 具体代码如下：123456789101112timeoutPromise(timeout) &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(new Response(&quot;timeout&quot;, &#123;status: 504, statusText: &quot;timeout &quot;&#125;)); // reject(new Error(&apos;请求超时&apos;)) controller.abort(); // 判断网络是否连接 // TODO... &#125;, timeout) &#125;);&#125; 123456789wrapperRequest(request) &#123; return Promise.race([this.timeoutPromise(10000), request]) .then(resp =&gt; &#123; return Promise.resolve(resp); &#125;) .catch(error =&gt; &#123; return Promise.reject(error); &#125;);&#125; 12345678910get(url, querystring = &#123;&#125;, options = &#123;&#125;) &#123; const getOptions = Object.assign( &#123; method: HTTP_METHOD.GET, qs: querystring, &#125;, options ); return this.wrapperRequest(this.sendRequest(url, getOptions));&#125; 方法二：clearTimeout()流程图 具体代码如下：1234567891011// Handle request timeoutif (options.timeout &amp;&amp; !this.timer) &#123; this.timer = setTimeout(function handleRequestTimeout() &#123; // reject(new Error(&apos;请求超时&apos;)) controller.abort(); reject(new Response(&quot;timeout&quot;, &#123;status: 504, statusText: &quot;timeout &quot;&#125;)); // 判断网络是否连接 // TODO... &#125;, options.timeout);&#125; 12345return fetch(url, apiOptions).then(response =&gt; &#123; // Response has been received so kill timer that handles request timeout clearTimeout(this.timer); this.timer = null;&#125;) 总结axios固然好用，但是我的宗旨是：自己动手，丰衣足食；自己写了网络请求响应模块，如果还需要其他功能，自己拓展，自己维护这个模块。方法一是网上给出的解决方案，思路固然好，但是对于正常平添了一个请求（一定会执行timeout的逻辑），而且无法满足我后续监听网络是否断开的操作（这个模块已经实现），有兴趣的朋友可以给我发邮件，后续我会新增这个模块的博客。方法二是借鉴axios的源码，对请求超时响应的处理","categories":[{"name":"axios","slug":"axios","permalink":"https://www.shengkesi.cn/categories/axios/"}],"tags":[{"name":"request","slug":"request","permalink":"https://www.shengkesi.cn/tags/request/"}]},{"title":"NodeJS Middleware","slug":"NodeJS-Middleware","date":"2020-02-03T06:59:38.000Z","updated":"2020-06-02T11:33:57.670Z","comments":true,"path":"NodeJS-Middleware/","link":"","permalink":"https://www.shengkesi.cn/NodeJS-Middleware/","excerpt":"Nodejs 作为中间层能做的事nodejs中间层能减少开发过程中的一些实际问题，比如跨域，也能分担后台开发人员的工作，比如文件上传服务器，也能做简单的即时消息聊天功能，都是基于nodejs的特性。 反向代理和跨域同源策略（SOP）是为了防止CSRF（跨域请求伪造）的攻击，浏览器引入的策略。","text":"Nodejs 作为中间层能做的事nodejs中间层能减少开发过程中的一些实际问题，比如跨域，也能分担后台开发人员的工作，比如文件上传服务器，也能做简单的即时消息聊天功能，都是基于nodejs的特性。 反向代理和跨域同源策略（SOP）是为了防止CSRF（跨域请求伪造）的攻击，浏览器引入的策略。 跨域的解决方案有很多，比如 JSONP Nodejs做反向代理 CORS”跨域资源共享”（Cross-origin resource sharing），现在使用最多的是后两种，nodejs做反向代理，改变HTTP协议中header的属性，是前端开发最常用的方式。 文件上传服务器项目中避免不了需要上传图片，Excel文件等上传文件的功能，需要上传进度，存储文件，压缩等操作用nodejs来实现文件上传，并且可异步上传多个文件，是再好不过的了 SSR服务器端渲染的好处有好多，提高首屏加载速度，提高搜索引擎对网页的抓取现基于 koa 做了服务器端渲染的操作 socket.ioSocket.io是一个WebSocket库，包括了客户端的js和服务器端的nodejs Express vs Koa express 门槛更低，koa 更强大更优雅。 express 封装更多的东西，开发速度快速，koa 可定制性更高 整体的项目架构图","categories":[{"name":"Nodejs","slug":"Nodejs","permalink":"https://www.shengkesi.cn/categories/Nodejs/"}],"tags":[{"name":"Nodejs","slug":"Nodejs","permalink":"https://www.shengkesi.cn/tags/Nodejs/"}]},{"title":"Flutter","slug":"Flutter","date":"2020-02-01T07:53:14.000Z","updated":"2020-06-02T11:33:57.657Z","comments":true,"path":"Flutter/","link":"","permalink":"https://www.shengkesi.cn/Flutter/","excerpt":"引语Flutter 是 Google 研发的 移动 UI 框架，可以快速在iOS和Android上构建高质量的原生用户界面。 DartDart 是 Flutter 的开发语言， 如同 IOS开发用 swift 一样, Flutter SDKFlutter SDK里面有什么？ 深度优化了的、移动优先的2D渲染引擎 现代、响应式框架 丰富的Android和iOS套件 单元和集成测试的API 连接到系统和第三方SDK的Interop和插件API 无头的测试运行器，用于在Windows、Linux和Mac上运行测试 用于创建、构建、测试和编译应用程序的命令行工具","text":"引语Flutter 是 Google 研发的 移动 UI 框架，可以快速在iOS和Android上构建高质量的原生用户界面。 DartDart 是 Flutter 的开发语言， 如同 IOS开发用 swift 一样, Flutter SDKFlutter SDK里面有什么？ 深度优化了的、移动优先的2D渲染引擎 现代、响应式框架 丰富的Android和iOS套件 单元和集成测试的API 连接到系统和第三方SDK的Interop和插件API 无头的测试运行器，用于在Windows、Linux和Mac上运行测试 用于创建、构建、测试和编译应用程序的命令行工具 IDEAndroid Studio 个人项目","categories":[{"name":"Flutter","slug":"Flutter","permalink":"https://www.shengkesi.cn/categories/Flutter/"}],"tags":[{"name":"Flutter","slug":"Flutter","permalink":"https://www.shengkesi.cn/tags/Flutter/"}]},{"title":"Mutiple SSH keys for diffrent github accounts","slug":"Mutiple-SSH-keys-for-diffrent-github-accounts","date":"2020-01-05T12:01:31.000Z","updated":"2020-06-02T11:33:58.334Z","comments":true,"path":"Mutiple-SSH-keys-for-diffrent-github-accounts/","link":"","permalink":"https://www.shengkesi.cn/Mutiple-SSH-keys-for-diffrent-github-accounts/","excerpt":"create different public keyNote: blog’s git configuration is global, others is in your project create different ssh key according to your need12$ ssh-keygen -t rsa -f ~/.ssh/id_rsa_activehacker -C &quot;jexlab@gmail.com&quot;$ ssh-keygen -t rsa -f ~/.ssh/id_rsa_jexchan -C &quot;jexchan@gmail.com&quot; If your command line has no arguments “-f ~/.ssh/id_rsa_activehacker”, as following 12$ ssh-keygen -t rsa -C &quot;jexlab@gmail.com&quot;$ ssh-keygen -t rsa -C &quot;jexchan@gmail.com&quot; 运行上面那条命令后会让输入一个文件名，用于保存刚才生成的 SSH key 代码，此时需要输入完整的绝对路径，或者只输入文件名，在当前目录生成，生成后移动到指定的.ssh文件夹内，如： 12Generating public/private rsa key pair.Enter file in which to save the key (/c/Users/SKS/.ssh/id_rsa): /c/Users/SKS/.ssh/id_rsa_activehacker","text":"create different public keyNote: blog’s git configuration is global, others is in your project create different ssh key according to your need12$ ssh-keygen -t rsa -f ~/.ssh/id_rsa_activehacker -C &quot;jexlab@gmail.com&quot;$ ssh-keygen -t rsa -f ~/.ssh/id_rsa_jexchan -C &quot;jexchan@gmail.com&quot; If your command line has no arguments “-f ~/.ssh/id_rsa_activehacker”, as following 12$ ssh-keygen -t rsa -C &quot;jexlab@gmail.com&quot;$ ssh-keygen -t rsa -C &quot;jexchan@gmail.com&quot; 运行上面那条命令后会让输入一个文件名，用于保存刚才生成的 SSH key 代码，此时需要输入完整的绝对路径，或者只输入文件名，在当前目录生成，生成后移动到指定的.ssh文件夹内，如： 12Generating public/private rsa key pair.Enter file in which to save the key (/c/Users/SKS/.ssh/id_rsa): /c/Users/SKS/.ssh/id_rsa_activehacker 你也可以不输入文件名，使用默认文件名，那么就会生成 id_rsa 和 id_rsa.pub 两个全局默认的秘钥文件，前者为私钥，后者为公钥。当然我们有两个代码仓库，所以最好写上文件名，如id_rsa(公司)或id_rsa_user2(个人). 这样ssh目录下会生成id_rsa.pub和id_rsa_user2.pub两个文件 接着又会提示你输入两次密码（该密码是你push文件的时候要输入的密码，而不是github管理者的密码）。也可以直接按回车键，那么push的时候就不需要输入密码，直接提交到github上了，如： 12Enter passphrase (empty for no passphrase):Enter same passphrase again: 当你看到下面这段代码的时候，那就说明，SSH key 已经创建成功，只需要添加到github的SSH key上就可以了。 1234Your identification has been saved in /c/Users/SKS/.ssh/id_rsa_activehacker.Your public key has been saved in /c/Users/SKS/.ssh/id_rsa_activehacker.pub.The key fingerprint is:SHA256:Iyie1VCcJRLoOmM2VvY/5XF4KPb9MbQpLmEeOLuVDfA jexlab@gmail.com 2 keys created at: 12~/.ssh/id_rsa_activehacker~/.ssh/id_rsa_jexchan then, add these two keys as following(添加到 ssh-agent 信任列表) 12$ ssh-add ~/.ssh/id_rsa_activehacker$ ssh-add ~/.ssh/id_rsa_jexchan you can delete all cached keys before 1$ ssh-add -D finally, you can check your saved keys 1$ ssh-add -l 请注意：此处有坑，你可能会遇到这样的问题 1Could not open a connection to your authentication agent. 解决方案：（也可以是其他的，参考资料里边stackoverflow里边的答案你都可以试试） 1$ ssh-agent bash 这之后，再添加。看到如下所示的情况，就证明添加成功了 12$ ssh-add ~/.ssh/id_rsa_activehackerIdentity added: /c/Users/dong/.ssh/id_rsa_activehacker (/c/Users/dong/.ssh/id_rsa_activehacker) 添加ssh-key到github在 Github 的后台，可以看到一个叫做 SSH and GPG keys 的选项：这里面列出了当前账号绑定的 SSH Key。 每一个 key 对应一台独立的设备。 设置好两个ssh key之后就要配置下它们的使用场景登录你的github账号，从右上角的设置（ Settings ）进入，然后点击菜单栏的 SSH key 进入页面添加 SSH key。点击 Add SSH key 按钮添加一个 SSH key 。把你复制的 SSH key 代码粘贴到 key 所对应的输入框中，记得 SSH key 代码的前后不要留有空格或者回车。当然，上面的 Title 所对应的输入框你也可以输入一个该 SSH key 显示在 github 上的一个别名。 Modify the ssh config123$ cd ~/.ssh/$ touch config$ subl -a config Then added 1234567891011#activehacker accountHost github.com-activehackerHostName github.comUser gitIdentityFile ~/.ssh/id_rsa_activehacker#jexchan accountHost github.com-jexchanHostName github.comUser gitIdentityFile ~/.ssh/id_rsa_jexchan 这样，在我们创建的 config 文件中，配置了两条记录。 分别指向两个 SSH key。 HostName是原本的域名 Host是与HostName对应的自定义的名字。 Clone you repo and modify your Git configclone your repo在项目的下载地址中，有一个 Use SSH 的链接，点击它之后，就可以得到 SSH 格式的地址比如 git@github.com:activehacker/gfs.git。 我们需要对它稍作加工，把域名部分替换成我们在 config 中配置的 Host： git@github.com-activehacker:activehacker/gfs.git。 1$ git clone git@github.com-activehacker:activehacker/gfs.git gfs_jexchan 这样本地仓库就和对应的密钥建立起了联系。 以后的操作中，都会自动使用这个 SSH key 来访问 Github 远程仓库了。 如果想同时在另外一个本地仓库使用其他 Github 账户，只需要在 ~/.ssh/config文件中配置好相应的 SSH key 和对应的 Host，就可以了。 cd gfs_jexchan and modify git config(为每个仓库单独设置用户) 12345$ git config user.name &quot;jexchan&quot;$ git config user.email &quot;jexchan@gmail.com&quot; $ git config user.name &quot;activehacker&quot;$ git config user.email &quot;jexlab@gmail.com&quot; then use normal flow to push your code 123$ git add .$ git commit -m &quot;your comments&quot;$ git push","categories":[{"name":"Git","slug":"Git","permalink":"https://www.shengkesi.cn/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://www.shengkesi.cn/tags/Git/"}]},{"title":"ES6 的新特性","slug":"ECMAScript6-New-Features","date":"2019-05-18T10:26:14.000Z","updated":"2020-06-02T11:33:57.655Z","comments":true,"path":"ECMAScript6-New-Features/","link":"","permalink":"https://www.shengkesi.cn/ECMAScript6-New-Features/","excerpt":"写这篇文章的目的就是告诉前端的同学们，ES6 已经是前端程序员必不可少的技能之一，后期再追加 Typescript 的新语法 关键字 async/await 的应用 async function 是 Promise 的语法糖封装 异步编程的终极方案 - 以同步的方式写异步 await 关键字可以 “暂停” async function 的执行 await 关键字可以以同步的写法获取 Promise 的执行结果 try-catch 可以获取 await 所得到的错误 一个穿越事件循环存在的 function","text":"写这篇文章的目的就是告诉前端的同学们，ES6 已经是前端程序员必不可少的技能之一，后期再追加 Typescript 的新语法 关键字 async/await 的应用 async function 是 Promise 的语法糖封装 异步编程的终极方案 - 以同步的方式写异步 await 关键字可以 “暂停” async function 的执行 await 关键字可以以同步的写法获取 Promise 的执行结果 try-catch 可以获取 await 所得到的错误 一个穿越事件循环存在的 function 用 async/await 来处理异步请求, 从服务端获取数据，代码更简洁，其已被标准化，用的最多的就是，当你后面的数据过滤整理操作，需要依赖于前面接口返回的数据时，此语法方便解决了此需求，注意：await 后面的函数必须返回一个promise想获取到async 函数的执行结果，就要调用promise的then 或catch 来给它注册回调函数（类同promise），代码如下： 123456789101112131415161718192021getTree() &#123; return getRegionTree() .then(res =&gt; &#123; this.interfaceData = res.data; this.interfaceData.name = &quot;选择区域&quot;; &#125;) .catch(err =&gt; &#123; console.log(err); &#125;);&#125;,async init(originArea, readonly) &#123; await this.getTree(); if (originArea) &#123; originArea.name = &quot;选择区域&quot;; let oldArray = this.handleEmptyTree([this.interfaceData], readonly); originArea = this.handleNotEmptyTree([originArea], readonly); this.handleLeafTree(originArea, oldArray); &#125; else &#123; this.region = this.handleEmptyTree([this.interfaceData]); &#125; &#125; 重点：vue 中 this.$nextTick() 也会返回一个promise，也可用 async/await，这在工作中很有用，解决一些组件不刷新数据的问题。例如： 123456async publishFn(name) &#123; this.isShowDiseaseTagsMessage = false; await this.$nextTick(() =&gt; &#123; this.isShowDiseaseTagsMessage = (this.queryModel.diseaseTags &amp;&amp; this.queryModel.diseaseTags.length === 0) &#125;)&#125; es6判断数组已存在某个对象。find() 方法返回数组中满足提供的测试函数的第一个元素的值。否则返回 undefined。findIndex()方法返回数组中满足提供的测试函数的第一个元素的索引。否则返回-1。 1234567var objArr = [&#123;id:1, name:&apos;jiankian&apos;&#125;, &#123;id:23, name:&apos;anan&apos;&#125;, &#123;id:188, name:&apos;superme&apos;&#125;, &#123;id:233, name:&apos;jobs&apos;&#125;, &#123;id:288, name:&apos;bill&apos;, age:89&#125;, &#123;id:333&#125;] ;var ret2 = objArr.find((v) =&gt; &#123; return v.id == 233;&#125;);console.log(ret2);// return &#123;id:233, name:&apos;jobs&apos;&#125;// 当返回undefined时，则说明objArr中没有，可以添加 1234567var objArr = [&#123;id:1, name:&apos;jiankian&apos;&#125;, &#123;id:23, name:&apos;anan&apos;&#125;, &#123;id:188, name:&apos;superme&apos;&#125;, &#123;id:233, name:&apos;jobs&apos;&#125;, &#123;id:288, name:&apos;bill&apos;, age:89&#125;, &#123;id:333&#125;] ;var ret2 = objArr.findIndex((v) =&gt; &#123; return v.id == 233;&#125;);console.log(ret2);// return 3// 当返回-1时，则说明objArr中没有，可以添加了 ES5和ES6中分别是怎么判断变量为数组的JS的弱类型机制导致判断变量类型，类型检查很重要，为编码的首要检索入口 在ES5中判断变量是否为数组1234567891011var a = []; // 1.基于instanceof a instanceof Array; // 2.基于constructor a.constructor === Array; // 3.基于Object.prototype.isPrototypeOf Array.prototype.isPrototypeOf(a); // 4.基于getPrototypeOf Object.getPrototypeOf(a) === Array.prototype; // 5.基于Object.prototype.toString Object.prototype.toString.apply(a) === &apos;[object Array]&apos;; 以上，除了Object.prototype.toString外，其它方法都不能正确判断变量的类型。 要知道，代码的运行环境十分复杂，一个变量可能使用浑身解数去迷惑它的创造者。且看： 123456789101112var a = &#123; __proto__: Array.prototype&#125;; // 分别在控制台试运行以下代码 // 1.基于instanceof a instanceof Array; // =&gt; true // 2.基于constructor a.constructor === Array; // =&gt; true // 3.基于Object.prototype.isPrototypeOf Array.prototype.isPrototypeOf(a); // =&gt; true // 4.基于getPrototypeOf Object.getPrototypeOf(a) === Array.prototype; // =&gt; true 以上，4种方法将全部返回true，为什么呢？我们只是手动指定了某个对象的proto属性为Array.prototype，便导致了该对象继承了Array对象，这种毫不负责任的继承方式，使得基于继承的判断方案瞬间土崩瓦解。 不仅如此，我们还知道，Array是堆数据，变量指向的只是它的引用地址，因此每个页面的Array对象引用的地址都是不一样的。iframe中声明的数组，它的构造函数是iframe中的Array对象。如果在iframe声明了一个数组x，将其赋值给父页面的变量y，那么在父页面使用y instanceof Array ，结果一定是false的。�而最后一种返回的是字符串，不会存在引用问题。实际上，多页面或系统之间的交互只有字符串能够畅行无阻。 当检测Array实例时, Array.isArray 优于 instanceof,因为Array.isArray能检测iframes. 123456789var iframe = document.createElement(&apos;iframe&apos;);document.body.appendChild(iframe);xArray = window.frames[window.frames.length-1].Array;var arr = new xArray(1,2,3); // [1,2,3]// Correctly checking for ArrayArray.isArray(arr); // true// Considered harmful, because doesn&apos;t work though iframesarr instanceof Array; // false 在ES6中判断变量是否为数组鉴于数组的常用性，在ES6中新增了Array.isArray方法，使用此方法判断变量是否为数组，则非常简单，如下 12Array.isArray([]); // =&gt; true Array.isArray(&#123;0: &apos;a&apos;, length: 1&#125;); // =&gt; false 实际上，通过Object.prototype.toString去判断一个值的类型，也是各大主流库的标准。因此Array.isArray的polyfill通常长这样：假如不存在 Array.isArray()，则在其他代码之前运行下面的代码将创建该方法。 12345if (!Array.isArray)&#123; Array.isArray = function(arg)&#123; return Object.prototype.toString.call(arg) === &apos;[object Array]&apos;; &#125;;&#125;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.shengkesi.cn/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.shengkesi.cn/tags/JavaScript/"}]},{"title":"在 react 项目的基础上增加一些配置（typescript支持，webpack别名等）","slug":"create-react-app-complex","date":"2019-03-12T01:47:05.000Z","updated":"2020-06-02T11:33:57.806Z","comments":true,"path":"create-react-app-complex/","link":"","permalink":"https://www.shengkesi.cn/create-react-app-complex/","excerpt":"引言react脚手架并不能直接运用到项目中去，需要改造，自己进行了进一步探索，总结创建项目的心酸历程 创建项目的流程 npx create-react-app jelly3 备注：你的环境没有全局安装npx，放心，它会自动安装上并执行创建项目的命令 cd jelly3 切换到自己创建项目根目录下 yarn eject yarn start 启动项目","text":"引言react脚手架并不能直接运用到项目中去，需要改造，自己进行了进一步探索，总结创建项目的心酸历程 创建项目的流程 npx create-react-app jelly3 备注：你的环境没有全局安装npx，放心，它会自动安装上并执行创建项目的命令 cd jelly3 切换到自己创建项目根目录下 yarn eject yarn start 启动项目 接下来就是思考自己的项目结构了如果你刚开始一个项目，不要花超过五分钟在选择一个文件结构上。从以上方法（或者你自己想到的）中任意挑一个然后开始编程吧！在写完一些真实的代码之后，你可能会想重新考虑它。 @歌特式灵魂摆渡人www.jianshu.com/p/eb7d518b05b8 引入路径别名发现更改目录结构后，相对路径的名字写起来很麻烦，想跟以前VUE项目一样，src 路径 以 别名 “@” 代替我们可以通过使用 webpack 中的 resolve.alias 配置别名，将某些文件目录配置成固定的引入。例如： 我们可以将 ../../src 这样的相对路径的目录，设置成一个 @ 别名， 以后就可以用 @ 代替这个目录引入就行了，而不需要写一坨 ../../../ 1234567891011const path = require(&apos;path&apos;);module.exports = &#123; ... resolve: &#123; alias: &#123; &apos;@&apos;: path.resolve(__dirname, &apos;../src&apos;) &#125; &#125;, ...&#125;; 给React项目添加TypeScript支持请参阅给React项目添加TypeScript支持, 多少跟实际项目有些出入，需要灵活变通，与官网的配置结合看最佳。熟悉webpack配置和总览生成项目的配置后，我发现已经对TypeScript部分支持（未对.ts和.tsx进行webpack解析）注：TypeScript 官网 有 React &amp; Webpack 这篇教程，但是有需要改进的地方, 比如 ts-loader 比 awesome-typescript-loader 打包速度更快， 构建项目大多数用 ts-loader, 详见Speed of Awesome-typescript-loader vs ts-loader 加入代码语法格式检查工具eslint + tslint 并不能满足自己的代码洁癖，后又引入了prettier vscode + prettier 专治代码洁癖，经过艰苦的VSCode插件和配置文件的调试过程，代码检查机制总算配置好了。 解决相关的问题 .tsx 文件中引入的 webpack 别名，TS语法检查报错的问题详见一次解决React+TypeScript+Webpack 别名（alias）找不到问题的过程 同时，当天发现react项目存在的问题就是 package.json 文件中，没有开发环境依赖和生产环境依赖的区分，把所有的依赖全部写入到了生产依赖中，如下 package.json123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121&#123; &quot;name&quot;: &quot;jelly3&quot;, &quot;version&quot;: &quot;0.2.0&quot;, &quot;private&quot;: true, &quot;dependencies&quot;: &#123; &quot;@babel/core&quot;: &quot;7.2.2&quot;, &quot;@svgr/webpack&quot;: &quot;4.1.0&quot;, &quot;babel-core&quot;: &quot;7.0.0-bridge.0&quot;, &quot;babel-eslint&quot;: &quot;9.0.0&quot;, &quot;babel-jest&quot;: &quot;23.6.0&quot;, &quot;babel-loader&quot;: &quot;8.0.5&quot;, &quot;babel-plugin-named-asset-import&quot;: &quot;^0.3.1&quot;, &quot;babel-preset-react-app&quot;: &quot;^7.0.1&quot;, &quot;bfj&quot;: &quot;6.1.1&quot;, &quot;case-sensitive-paths-webpack-plugin&quot;: &quot;2.2.0&quot;, &quot;css-loader&quot;: &quot;1.0.0&quot;, &quot;dotenv&quot;: &quot;6.0.0&quot;, &quot;dotenv-expand&quot;: &quot;4.2.0&quot;, &quot;eslint&quot;: &quot;5.12.0&quot;, &quot;eslint-config-react-app&quot;: &quot;^3.0.7&quot;, &quot;eslint-loader&quot;: &quot;2.1.1&quot;, &quot;eslint-plugin-flowtype&quot;: &quot;2.50.1&quot;, &quot;eslint-plugin-import&quot;: &quot;2.14.0&quot;, &quot;eslint-plugin-jsx-a11y&quot;: &quot;6.1.2&quot;, &quot;eslint-plugin-react&quot;: &quot;7.12.4&quot;, &quot;file-loader&quot;: &quot;2.0.0&quot;, &quot;fork-ts-checker-webpack-plugin-alt&quot;: &quot;0.4.14&quot;, &quot;fs-extra&quot;: &quot;7.0.1&quot;, &quot;html-webpack-plugin&quot;: &quot;4.0.0-alpha.2&quot;, &quot;identity-obj-proxy&quot;: &quot;3.0.0&quot;, &quot;jest&quot;: &quot;23.6.0&quot;, &quot;jest-pnp-resolver&quot;: &quot;1.0.2&quot;, &quot;jest-resolve&quot;: &quot;23.6.0&quot;, &quot;jest-watch-typeahead&quot;: &quot;^0.2.1&quot;, &quot;mini-css-extract-plugin&quot;: &quot;0.5.0&quot;, &quot;node-sass&quot;: &quot;^4.12.0&quot;, &quot;optimize-css-assets-webpack-plugin&quot;: &quot;5.0.1&quot;, &quot;pnp-webpack-plugin&quot;: &quot;1.2.1&quot;, &quot;postcss-flexbugs-fixes&quot;: &quot;4.1.0&quot;, &quot;postcss-loader&quot;: &quot;3.0.0&quot;, &quot;postcss-preset-env&quot;: &quot;6.5.0&quot;, &quot;postcss-safe-parser&quot;: &quot;4.0.1&quot;, &quot;react&quot;: &quot;^16.8.3&quot;, &quot;react-app-polyfill&quot;: &quot;^0.2.1&quot;, &quot;react-dev-utils&quot;: &quot;^7.0.3&quot;, &quot;react-dom&quot;: &quot;^16.8.3&quot;, &quot;resolve&quot;: &quot;1.10.0&quot;, &quot;sass-loader&quot;: &quot;7.1.0&quot;, &quot;style-loader&quot;: &quot;0.23.1&quot;, &quot;terser-webpack-plugin&quot;: &quot;1.2.2&quot;, &quot;url-loader&quot;: &quot;1.1.2&quot;, &quot;webpack&quot;: &quot;4.28.3&quot;, &quot;webpack-dev-server&quot;: &quot;3.1.14&quot;, &quot;webpack-manifest-plugin&quot;: &quot;2.0.4&quot;, &quot;workbox-webpack-plugin&quot;: &quot;3.6.3&quot; &#125;, &quot;scripts&quot;: &#123; &quot;start&quot;: &quot;node scripts/start.js&quot;, &quot;build&quot;: &quot;node scripts/build.js&quot;, &quot;test&quot;: &quot;node scripts/test.js&quot; &#125;, &quot;eslintConfig&quot;: &#123; &quot;extends&quot;: &quot;react-app&quot; &#125;, &quot;browserslist&quot;: [ &quot;&gt;0.2%&quot;, &quot;not dead&quot;, &quot;not ie &lt;= 11&quot;, &quot;not op_mini all&quot; ], &quot;jest&quot;: &#123; &quot;collectCoverageFrom&quot;: [ &quot;src//*.&#123;js,jsx,ts,tsx&#125;&quot;, &quot;!src//.d.ts&quot; ], &quot;resolver&quot;: &quot;jest-pnp-resolver&quot;, &quot;setupFiles&quot;: [ &quot;react-app-polyfill/jsdom&quot; ], &quot;testMatch&quot;: [ &quot;&lt;rootDir&gt;/src//tests//.&#123;js,jsx,ts,tsx&#125;&quot;, &quot;&lt;rootDir&gt;/src/*/?(.)(spec|test).&#123;js,jsx,ts,tsx&#125;&quot; ], &quot;testEnvironment&quot;: &quot;jsdom&quot;, &quot;testURL&quot;: &quot;http://localhost&quot;, &quot;transform&quot;: &#123; &quot;^.+\\.(js|jsx|ts|tsx)$&quot;: &quot;&lt;rootDir&gt;/node_modules/babel-jest&quot;, &quot;^.+\\.css$&quot;: &quot;&lt;rootDir&gt;/config/jest/cssTransform.js&quot;, &quot;^(?!.*\\.(js|jsx|ts|tsx|css|json)$)&quot;: &quot;&lt;rootDir&gt;/config/jest/fileTransform.js&quot; &#125;, &quot;transformIgnorePatterns&quot;: [ &quot;[/\\\\]node_modules[/\\\\].+\\.(js|jsx|ts|tsx)$&quot;, &quot;^.+\\.module\\.(css|sass|scss)$&quot; ], &quot;moduleNameMapper&quot;: &#123; &quot;^react-native$&quot;: &quot;react-native-web&quot;, &quot;^.+\\.module\\.(css|sass|scss)$&quot;: &quot;identity-obj-proxy&quot; &#125;, &quot;moduleFileExtensions&quot;: [ &quot;web.js&quot;, &quot;js&quot;, &quot;web.ts&quot;, &quot;ts&quot;, &quot;web.tsx&quot;, &quot;tsx&quot;, &quot;json&quot;, &quot;web.jsx&quot;, &quot;jsx&quot;, &quot;node&quot; ], &quot;watchPlugins&quot;: [ &quot;E:\\Study\\jelly3\\node_modules\\jest-watch-typeahead\\filename.js&quot;, &quot;E:\\Study\\jelly3\\node_modules\\jest-watch-typeahead\\testname.js&quot; ] &#125;, &quot;babel&quot;: &#123; &quot;presets&quot;: [ &quot;react-app&quot; ] &#125;&#125;根据我以往的经验，把这些依赖进行了拆解，分成开发依赖（devDependencies，其中大部分是开发依赖）和 生产依赖 （dependencies）最新的 package.json 相关配置，请参考我的 github - jelly3 typescript里面引入图片时，TS语法检查报错，项目没办法正常启动参阅了(https://stackoverflow.com/questions/43638454/webpack-typescript-image-import?rq=1)，解决了这个问题。 为项目引入react-router(v4) 、antd-mobileyarn add react-router-domantd-mobile 请参照官网进行配置和引入，最好是按需加载遇到的问题：如果babel-plugin-import按需加载的js不符合tslint规范，怎么办？修改 tslint 的语法检查配置tsconfig.json 中添加 “allowSyntheticDefaultImports”: true, // 允许模块没有默认导出 浏览器兼容问题—babel-polyfill代码分割，路由动态加载（react-loadable）(react-loadable)[https://github.com/jamiebuilds/react-loadable] 高阶组件：路由守卫模拟VUE的路由守卫机制 react按需引入(lodash)[https://www.cnblogs.com/savokiss/p/8514868.html]定制antd-mobile主题vsCode安装函数注释插件（KoroFileHeader ）和git源代码管理插件（GitLens）、Import Cost、REST Client、vscode-icons添加webpack对less和sass的解析配置","categories":[{"name":"React","slug":"React","permalink":"https://www.shengkesi.cn/categories/React/"}],"tags":[{"name":"React","slug":"React","permalink":"https://www.shengkesi.cn/tags/React/"},{"name":"TypeScript","slug":"TypeScript","permalink":"https://www.shengkesi.cn/tags/TypeScript/"}]},{"title":"react的基础之上进行引入webpack、eslint、babel的框架搭建","slug":"create-react-app-simple","date":"2019-03-04T07:13:00.000Z","updated":"2020-06-02T11:33:57.923Z","comments":true,"path":"create-react-app-simple/","link":"","permalink":"https://www.shengkesi.cn/create-react-app-simple/","excerpt":"引言开始深入研究reactjs，弥补之前的浅尝辄止；一开始自己用官方的项目生成器生成了一个简单的架构，自己从这个简化版逐步加入babel, webpack, eslint 等相关的配置，有兴趣的朋友可以移步 react的基础之上进行引入webpack、eslint、babel的框架搭建, 但是你仔细阅读react项目下的 READEME.md, 你就会发现我绕了远路，其实react提供了 yarn eject 来注入webpack, eslint, label 等相关依赖和配置，可能这就是react给大家提供的 脚手架 吧 需要注意的是：这个命令只能执行一次，而且不可逆转。 虽说自己饶了远路，但是还是学到些东西的，也温习了一些 webpack，babel 的配置和原理等，想亲自动手，亲自实践的朋友按照如下步骤进行就行，我已经为你们绕过了一些坑比如：babel 升级 6.x 到 7.x, 请参阅 babel 7.x 和 webpack 4.x 配置vue项目, 如果以下步骤有什么不妥之处，欢迎大家给我评论，我会及时修正并回复大家的问题。","text":"引言开始深入研究reactjs，弥补之前的浅尝辄止；一开始自己用官方的项目生成器生成了一个简单的架构，自己从这个简化版逐步加入babel, webpack, eslint 等相关的配置，有兴趣的朋友可以移步 react的基础之上进行引入webpack、eslint、babel的框架搭建, 但是你仔细阅读react项目下的 READEME.md, 你就会发现我绕了远路，其实react提供了 yarn eject 来注入webpack, eslint, label 等相关依赖和配置，可能这就是react给大家提供的 脚手架 吧 需要注意的是：这个命令只能执行一次，而且不可逆转。 虽说自己饶了远路，但是还是学到些东西的，也温习了一些 webpack，babel 的配置和原理等，想亲自动手，亲自实践的朋友按照如下步骤进行就行，我已经为你们绕过了一些坑比如：babel 升级 6.x 到 7.x, 请参阅 babel 7.x 和 webpack 4.x 配置vue项目, 如果以下步骤有什么不妥之处，欢迎大家给我评论，我会及时修正并回复大家的问题。 创建项目的流程 npx create-react-app jelly备注：你的环境没有全局安装npx，放心，它会自动安装上并执行创建项目的命令 cd jelly 切换到自己创建项目根目录下 导入 react-dom 、react-router-dom 、 redux 、 react-redux 、lodash 依赖包yarn add react-dom react-router-dom redux react-redux lodash 安装 Webpack, 现在最流行的模块打包工具yarn add webpack webpack-cli webpack-dev-server webpack-merge –dev 安装一些必要的 Webpack 打包插件 和 eslintyarn add html-webpack-plugin copy-webpack-plugin css-loader file-loader eslint babel-eslint –dev 安装Babel, 可以把ES6转换为ES5，注意Babel最新的V6版本分为babel-cli和babel-core两个模块，这里只需要用babel-core即可yarn add @babel/core –dev 安装其他的babel依赖yarn add @babel/polyfill @babel/runtime @babel/plugin-transform-runtime @babel/preset-env @babel/preset-react –dev 安装 cross-env ， cross-env能跨平台地设置及使用环境变量yarn add cross-env –dev 打开 package.json , 添加或者修改下面的命令脚本 package.json12345&quot;scripts&quot;: &#123; &quot;start&quot;: &quot;cross-env NODE_ENV=development webpack-dev-server --cache --colors --profile --progress -d&quot;, &quot;build&quot;: &quot;cross-env NODE_ENV=production webpack --cache --colors --profile --progress --hide-modules&quot;&#125; 命令行输入 yarn start 将要启动 webpack dev server.命令行输入 yarn build 将会进行生产环境打包. 要想成功用webpack打包，还需要 webpack.config.js 和 webpack.ini.js , .babelrc","categories":[{"name":"React","slug":"React","permalink":"https://www.shengkesi.cn/categories/React/"}],"tags":[{"name":"React","slug":"React","permalink":"https://www.shengkesi.cn/tags/React/"}]},{"title":"JS 的深拷贝与浅拷贝","slug":"deep-copy-and-shallow-copy-for-JavaScript","date":"2019-02-24T01:21:09.000Z","updated":"2020-06-02T11:33:58.107Z","comments":true,"path":"deep-copy-and-shallow-copy-for-JavaScript/","link":"","permalink":"https://www.shengkesi.cn/deep-copy-and-shallow-copy-for-JavaScript/","excerpt":"原文链接作者：ziwei3749https://segmentfault.com/a/1190000012828382 这篇文章的受众 第一类,业务需要,急需知道如何深拷贝JS对象的开发者。 第二类,希望扎实JS基础,将来好去面试官前秀操作的好学者。 写给第一类读者你只需要一行黑科技代码就可以实现深拷贝 123456var copyObj = &#123; name: &apos;ziwei&apos;, arr : [1,2,3]&#125;var targetObj = JSON.parse(JSON.stringify(copyObj)) 此时 copyObj.arr !== targetObj.arr 已经实现了深拷贝 别着急走,利用window.JSON的方法做深拷贝存在2个缺点: 如果你的对象里有函数,函数无法被拷贝下来 无法拷贝copyObj对象原型链上的属性和方法","text":"原文链接作者：ziwei3749https://segmentfault.com/a/1190000012828382 这篇文章的受众 第一类,业务需要,急需知道如何深拷贝JS对象的开发者。 第二类,希望扎实JS基础,将来好去面试官前秀操作的好学者。 写给第一类读者你只需要一行黑科技代码就可以实现深拷贝 123456var copyObj = &#123; name: &apos;ziwei&apos;, arr : [1,2,3]&#125;var targetObj = JSON.parse(JSON.stringify(copyObj)) 此时 copyObj.arr !== targetObj.arr 已经实现了深拷贝 别着急走,利用window.JSON的方法做深拷贝存在2个缺点: 如果你的对象里有函数,函数无法被拷贝下来 无法拷贝copyObj对象原型链上的属性和方法 当然,你明确知道他们的缺点后,如果他的缺点对你的业务需求没有影响,就可以放心使用了,一行原生代码就能搞定。目前我在开发业务场景中,大多还真可以忽略上面2个缺点。往往需要深拷贝的对象里没有函数,也不需要拷贝它原型链的属性。 写给第二类读者下面我会尽可能全面的讲解清楚JS里对象的拷贝,要讲清楚拷贝,你需要一点点前置知识 你需要的前置知识: 理解JS里的引用类型和值类型的区别,知道Obj存储的只是引用 对原型链有基本了解 关于对象拷贝的全部: 深拷贝、浅拷贝是什么 深拷贝、浅拷贝在业务里的最常见的应用场景 深拷贝和浅拷贝的实现方式 总结与建议 1. 深拷贝、浅拷贝是什么我们讨论JS对象深拷贝、浅拷贝的前提 只有对象里嵌套对象的情况下,才会根据需求讨论,我们要深拷贝还是浅拷贝。 比如下面这种对象 1234var obj1 = &#123; name: &apos;ziwei&apos;, arr : [1,2,3]&#125;因为,如果是类似这样{name: ‘ziwei’},没有嵌套对象的对象的话,就没必要区分深浅拷贝了。只有在有嵌套的对象时,深拷贝和浅拷贝才有区别浅拷贝是什么样子的 (我们暂时不管具体如何实现,因为下面会单讲)调用shallowCopy()后,obj2拷贝obj1所有的属性。但是obj2.arr和obj1.arr是不同的引用,指向同一个内存空间12345var obj2 = shallowCopy( obj1 , &#123;&#125;)console.log( obj1 !== obj2 ) // true 无论哪种拷贝,obj1和obj2一定都是2个不同的对象(内存空间不同)console.log( obj2.arr === obj1.arr ) // true 他们2个对象里arr的引用,指向【相同的】内存空间 所以, 2个obj经过拷贝后,虽然他们属性相同,也的确是不同的对象,但他们内部的obj都是指向同一个内存空间,这种我们叫浅拷贝 深拷贝是什么样子的 (我们暂时不管具体如何实现,因为下面会单讲) 调用deepCopy()后,obj2拷贝obj1所有的属性,而且obj2.arr和obj1.arr是指向不同的内存空间, 2个obj2除了拷贝了一样的属性,没有任何其他关联。 12345var obj2 = deepCopy( obj1 , &#123;&#125;)console.log( obj1 !== obj2 ) // true 无论哪种拷贝,obj1和obj2一定都是2个不同的对象(内存空间不同)console.log( obj2.arr === obj1.arr ) // false 他们2个对象里arr的引用,指向【不同的】内存空间 所以, 2个obj经过拷贝后,除了拷贝下来相同的属性之外,没有任何其他关联的2个对象,这种我们叫深拷贝 2. 深拷贝在业务里的最常见的应用场景举个栗子,业务需求是 : 一个表格展示商品各种信息,点击【同意】时,是可以弹出对话框调整商品数量的。 这种业务需求下,我们就会用到对象的深拷贝。因为【商品表格】的属性和【调整商品表格】的属性几乎一样,我们需要拷贝。 下面的伪代码和图片就是展示使用浅拷贝存在的问题 这样得到的adjustTableArr和tableArr里,内部对象都是相同的,所以就出现了图中红线标注的情况, 当我们修改【调整商品表格】里的商品数量时,【商品表格】也跟着改变了,这并不是我们想要的 123456789101112// 表格对象的数据结构var tableArr = [ &#123;goods_name : &apos;长袖腰背夹&apos; , code : &apos;M216C239E0864&apos; , num : &apos;2&apos;&#125;, &#123;goods_name : &apos;长袖腰背夹&apos; , code : &apos;M216C240B0170&apos; , num : &apos;3&apos;&#125;, &#123;goods_name : &apos;短塑裤&apos; , code : &apos;M216D241C04106&apos; , num : &apos;3&apos;&#125;, ] var adjustTableArr = [] // 调整表格用的数组for (var key in tableArr) &#123; // 浅拷贝 adjustTableArr[key] = tableArr[key]&#125; 而实际上,我们希望这2个表格里的数据完全独立,互不干扰,只有在确认调整之后才刷新商品数量。 这种情况下我们就可以使用前面说的深拷贝的一行黑科技 1var adjustTableArr = JSON.parse(JSON.stringify(tableArr)) 还记得它的缺陷吗? 对象里的函数无法被拷贝,原型链里的属性无法被拷贝。这里就对业务没有影响,可以很方便的深拷贝。 3. 深拷贝和浅拷贝的实现方式其实JQ里已经有$.extend()函数,实现就是深拷贝和浅拷贝的功能。有兴趣的小伙伴也可以看看源码。 浅拷贝 浅拷贝比较简单,就是用for in 循环赋值 123456789function shallowCopy(source, target = &#123;&#125;) &#123; var key; for (key in source) &#123; if (source.hasOwnProperty(key)) &#123; // 意思就是proto上面的属性,我不拷贝 target[key] = source[key]; &#125; &#125; return target;&#125; 深拷贝的实现 深拷贝,就是遍历那个被拷贝的对象 判断对象里每一项的数据类型 如果不是对象类型,就直接赋值,如果是对象类型,就再次调用deepCopy,递归的去赋值。 1234567891011121314function deepCopy(source, target = &#123;&#125;) &#123; var key; for (key in source) &#123; if (source.hasOwnProperty(key)) &#123; // 意思就是proto上面的属性,我不拷贝 if (typeof(source[key]) === &quot;object&quot;) &#123; // 如果这一项是object类型,就递归调用deepCopy target[key] = Array.isArray(source[key]) ? [] : &#123;&#125;; deepCopy(source[key], target[key]); &#125; else &#123; // 如果不是object类型,就直接赋值拷贝 target[key] = source[key]; &#125; &#125; &#125; return target;&#125; 以上的无论深、浅拷贝,都用了source.hasOwnProperty(key),意思是判断这一项是否是其自有属性,是的话才拷贝,不是就不拷贝。 也就是说proto上面的属性,我不拷贝。这个其实你可以根据业务需求,来决定加上和这个条件 (JQ的$.extend()是会连proto上的属性也拷贝下来的,但是是直接拷贝到对象上,而不是放到之前的proto上) 4. 总结与建议虽然大家可能经常用框架提供的api来实现深拷贝。 这篇文章分享的目的,更多还是希望用一篇文章整理清楚深浅拷贝的含义、递归实现思路,以及小伙伴们如果使用了JSON.parse()这种黑科技,一定要清楚这样写的优缺点。 5. 修正上面的deepCopy方法有漏洞，没有考虑source一开始就是数组的情况 下面是一个修改后版本 1234567891011function deepCopy( source ) &#123; let target = Array.isArray( source ) ? [] : &#123;&#125; for ( var k in source ) &#123; if ( typeof source[ k ] === &apos;object&apos; ) &#123; target[ k ] = deepCopy( source[ k ] ) &#125; else &#123; target[ k ] = source[ k ] &#125; &#125; return target&#125;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.shengkesi.cn/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.shengkesi.cn/tags/JavaScript/"}]},{"title":"前端工程师成长的痛，你占几条？","slug":"前端工程师成长的痛，你占几条？","date":"2019-02-23T01:48:01.000Z","updated":"2020-05-20T17:09:17.000Z","comments":true,"path":"前端工程师成长的痛，你占几条？/","link":"","permalink":"https://www.shengkesi.cn/前端工程师成长的痛，你占几条？/","excerpt":"原文链接作者：真传Xhttps://mp.weixin.qq.com/s?__biz=MzAxODE2MjM1MA==&amp;mid=2651555898&amp;idx=1&amp;sn=1a523de9728c65c03bc851620a06240e 引言对于很多前端工程师，很容易进入工作的舒适区，该熟悉的业务已熟悉了，然后就是重复用轮子，这样很容易让自己的成长处于原地打转以及低水平重复的状态。 去年11月，我们累计交流了203人（1-3年的前端工程师，遇到职业瓶颈），有的是主观原因造成的 ，有的是客观原因造成的，本文从客观跟主观两方面进行了总结，帮助大家 自检 。","text":"原文链接作者：真传Xhttps://mp.weixin.qq.com/s?__biz=MzAxODE2MjM1MA==&amp;mid=2651555898&amp;idx=1&amp;sn=1a523de9728c65c03bc851620a06240e 引言对于很多前端工程师，很容易进入工作的舒适区，该熟悉的业务已熟悉了，然后就是重复用轮子，这样很容易让自己的成长处于原地打转以及低水平重复的状态。 去年11月，我们累计交流了203人（1-3年的前端工程师，遇到职业瓶颈），有的是主观原因造成的 ，有的是客观原因造成的，本文从客观跟主观两方面进行了总结，帮助大家 自检 。 一、客观原因 没有经过系统的计算机学科学习导致计算机功底不扎实 这种问题主要出现在以下三类小伙伴身上： （1）计算机科班出身，但是在校期间基础不扎实。 （2）非计算机科班，通过自学，但不够系统，所学不成体系。 （3）非计算机科班，通过0基础的培训班，短时间速成，不够扎实。 因工作环境环境限制，导致成长性不足 以上客观主要导致问题表现如下： 因一些基础算法、数据结构理论不扎实导致一些编程思维难于理解。 比如 原型链，如果清楚 数据结构中链表结构，那么这个东西不难理解，再比如 哈希值，懂得数据结构中哈希表，哈希值也就迎刃而解。 计算机体系结构、操作系统理论、网络理论不扎实导致到后期一些东西难于理解。 比如有同学从前端学习入手，后来学习node开发 ，在 I/O ,进程、线程、IPC 、线程锁方面有些概念就比较难于理解，而导致不能很好得使用node 的api 。 工作业务型驱动，重复低水平劳动，基本上工作第一年对前端开发已经比较熟悉了，每天做表层业务模块，重复做已经会的东西，技术深度没有成长。 工作环境中无高手，前端开发团队大家水平相当，没有高手能够指导自己进入下一个层次。 二、主观原因 没有意识建立自己的底层系统 前端整体体系架构没有做过深入思考，导致用会用，但不知道为什么用，用另外一个有什么区别。 个人行动力不足，没有针对性的刻意练习 （1）有意识但是没有行动，比如网盘收集了一堆资料或者一堆视频，然后就没有然后了。 （2）自律性不足，很容易被外界影响，导致时间碎片化。 三、提升路径 学习东西，自学是一种途径，然而在自学的过程中，很多人处于不知道自己不知道的状态，无监督 ，非常容易放弃。 另一种是跟着高手，开阔视野，达到 知道自己不知道的境界，从而有方向，在短时期内进入到一个新的境界，节约时间成本，借助外力突破瓶颈。 @真传Xmp.weixin.qq.com/s?__biz=MzAxODE2MjM1MA==&mid=2651555898&idx=1&sn=1a523de9728c65c03bc851620a06240e","categories":[{"name":"随笔","slug":"随笔","permalink":"https://www.shengkesi.cn/categories/随笔/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://www.shengkesi.cn/tags/随笔/"}]},{"title":"Hexo-主题文件夹上传不到自己的github上","slug":"Hexo-主题文件夹上传不到自己的github上","date":"2019-02-10T06:44:49.000Z","updated":"2020-06-02T11:33:57.659Z","comments":true,"path":"Hexo-主题文件夹上传不到自己的github上/","link":"","permalink":"https://www.shengkesi.cn/Hexo-主题文件夹上传不到自己的github上/","excerpt":"引言好多人都已经用Hexo博客框架搭建了自己的博客，而且也部署到了自己的github上（或者是自己的云服务器上），再简单购买一个域名，让别人也可浏览自己的博客。但是搭建过程中遇到了好多坑，自己的博客代码上传至自己的github上，但是发现除了主题文件夹下的文件，其他都 push 上去了 而自己本地的主题文件夹是有文件的 探索大家可能想到是因为.gitignore里面忽略了这两个文件夹下的所有文件，但是经过自己的检查，发现并不是这儿的问题，自己的项目的.gitignore内容如下：","text":"引言好多人都已经用Hexo博客框架搭建了自己的博客，而且也部署到了自己的github上（或者是自己的云服务器上），再简单购买一个域名，让别人也可浏览自己的博客。但是搭建过程中遇到了好多坑，自己的博客代码上传至自己的github上，但是发现除了主题文件夹下的文件，其他都 push 上去了 而自己本地的主题文件夹是有文件的 探索大家可能想到是因为.gitignore里面忽略了这两个文件夹下的所有文件，但是经过自己的检查，发现并不是这儿的问题，自己的项目的.gitignore内容如下： 真正的解决办法经过多番探索，终于找到了症结，先来说如何解决 凡是通过git clone从github上拉取的代码，删除除了项目根目录以外的任何位置的 .git文件夹，.gitignore (或者编辑这个文件夹，删除那些你想上传但是被忽略的文件或文件夹) 和 .github 文件夹 操作完成之后，用SourceTree还是看不到需要上传的主题文件在“未暂存文件”一栏中，不要失望接着往下看 还要删除掉 SourceTree 中的 主题 子模块 ，如下图： 删除时，一定要勾选 “强制删除” ，要不然会删除不掉，而且SourceTree报错 出现此问题的原因主要根源是每次我们下载主题时，都会用git命令clone源代码，例如像这样： 1$ git clone --branch v5.1.2 https://github.com/iissnan/hexo-theme-next themes/next 最终导致自己的主题文件夹下多了个.git文件夹，会被认为是另一个资源库，从属于自己的项目之下，在SourceTree中显示成“子模块”，而这些项目需要的主题文件不会被push到自己的github仓库中。","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://www.shengkesi.cn/categories/Hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://www.shengkesi.cn/tags/hexo/"}]},{"title":"Hexo 插入图片","slug":"Hexo-插入图片","date":"2019-02-09T06:13:18.000Z","updated":"2020-06-02T11:33:57.663Z","comments":true,"path":"Hexo-插入图片/","link":"","permalink":"https://www.shengkesi.cn/Hexo-插入图片/","excerpt":"引言图片资源放在本地 source/ 文件夹后，本地服务器浏览时图片正常显示，但部署到 github 上会找不到图片。 究其原因，是图片路径出现问题。开始时自己在 source/ 文件夹下建了 assets 文件夹，专门用于存放文章相关的图片： 12345source |- _posts |- assets |- images |- image-1.png 使用 markdown 引用图片的方式为 1![hexo image](../../assets/images/image-1.png) 查看结构，发现部署以后，图片会自动添加日期相关的文件结构目录： 而实际存放的目录是 http://www.shengkesi.cn/assets/images/image-1.png ，导致图片资源访问不到。 为了解决这个问题查了很多资料，才知道原来除了本地存放图片，还可以使用图床。","text":"引言图片资源放在本地 source/ 文件夹后，本地服务器浏览时图片正常显示，但部署到 github 上会找不到图片。 究其原因，是图片路径出现问题。开始时自己在 source/ 文件夹下建了 assets 文件夹，专门用于存放文章相关的图片： 12345source |- _posts |- assets |- images |- image-1.png 使用 markdown 引用图片的方式为 1![hexo image](../../assets/images/image-1.png) 查看结构，发现部署以后，图片会自动添加日期相关的文件结构目录： 而实际存放的目录是 http://www.shengkesi.cn/assets/images/image-1.png ，导致图片资源访问不到。 为了解决这个问题查了很多资料，才知道原来除了本地存放图片，还可以使用图床。 图床所谓图床，就是储存图片的服务器，支持创建图片的对外链接地址便于引用。使用时只要引入图片的绝对地址就可以，方便简单。 图床分为免费和收费的。无论是国内还是国外的免费图床都存在隐患，毕竟小本买卖，一旦停止服务，图片自然也就变成了小红叉。收费图床稳定一些，不管从服务还是稳定性上，都更推荐收费图床。 目前大家推荐比较多的国内图床： 七牛云储存新注册用户可免费使用 10G 存储空间。 极简图床其实也是依赖七牛云储存账号的。 本地图片在本地存放图片的方法经过修改以后也可以完美使用。重点在于 _config.yml 文件中设置 post_asset_folder: true，开启资源文件夹功能，该功能支持用户通过相对路径标签引用资源。 下面我们来看会发生什么。执行 hexo new [layout] [title]创建一篇新的文章，会发现 source/_posts 下自动生成了一个和 md 文件同名的目录（也可以自己手动创建），这就是用于存放与文章有关的图片文件夹。 例如，我们想写一篇名为 hexo.md 的文章，执行 hexo new “hexo”，那么 _post 文件夹下的结构将是： 123_posts |- hexo.md |_ hexo 将相关的图片放入 hexo 文件夹 1234_posts |- hexo.md |_ hexo |_ image-2.png 需要注意的是，使用该种方式在 markdown 文件中引用图片将不再使用 markdown 语法，而是使用标签插件引用相对路径，否则可能造成图片和其他资源显示不正确。引用语法如下： 123&#123;% asset_path slug %&#125;&#123;% asset_img slug [title] %&#125;&#123;% asset_link slug [title] %&#125; 在上述语法下，插入图片的方法： 1&#123;% asset_img image-2.png This is an example image %&#125; 查看页面，发现图片已经可以正常显示了，图片的路径和实际存放目录是一致的。 如果想使用 markdown 语法插入相对路径的图片，可以利用插件。设置 post_asset_folder:true 后，在根目录下执行： 1npm install https://github.com/CodeFalling/hexo-asset-image --save 确保在 source/_posts 下创建和 markdown 文件同名的目录，里面存放需要的图片，然后在 markdown 中插入图片： 1! [hexo image] (hexo/image-1.png) 生成的页面中图片引用路径 1&lt;img src=&quot;/2019/02/10/hexo/image-1.png&quot; alt=&quot;hexo image&quot;&gt; 至此，用 markdown 完美实现本地图片插入。 参考文档：https://hexo.io/zh-cn/docs/asset-folders.html","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://www.shengkesi.cn/categories/Hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://www.shengkesi.cn/tags/hexo/"}]},{"title":"vue指令中寻找元素parentNode为null的问题（指令中钩子函数的运用）","slug":"vue指令中寻找元素parentNode为null的问题（指令中钩子函数的运用）","date":"2019-01-23T04:20:59.000Z","updated":"2020-06-02T11:33:58.120Z","comments":true,"path":"vue指令中寻找元素parentNode为null的问题（指令中钩子函数的运用）/","link":"","permalink":"https://www.shengkesi.cn/vue指令中寻找元素parentNode为null的问题（指令中钩子函数的运用）/","excerpt":"引语在VUE中运用 VUE 指令，发现之前的写法存在问题，刷新页面后报错，先贴代码， 再看报错 12345678// 权限指令Vue.directive('has', &#123; bind: function (el, binding) &#123; if (el.parentNode &amp;&amp; !Vue.prototype.$_has(binding.value)) &#123; el.parentNode.removeChild(el) &#125; &#125;&#125;) 只要刷新页面会出现如下问题：","text":"引语在VUE中运用 VUE 指令，发现之前的写法存在问题，刷新页面后报错，先贴代码， 再看报错 12345678// 权限指令Vue.directive('has', &#123; bind: function (el, binding) &#123; if (el.parentNode &amp;&amp; !Vue.prototype.$_has(binding.value)) &#123; el.parentNode.removeChild(el) &#125; &#125;&#125;) 只要刷新页面会出现如下问题： 猜测并寻找出现报错的原因看到这样的报错就顺藤摸瓜到这个VUE指令中，初步猜想是 函数中 el 元素未找到，但实际则是 el 元素的父节点 el.parentNode 未找到，值为 null，于是写如下代码验证自己的猜测 123456789101112// 权限指令Vue.directive('has', &#123; bind: function (el, binding) &#123; console.log(el.parentNode) if (el.parentNode &amp;&amp; !Vue.prototype.$_has(binding.value)) &#123; el.parentNode.removeChild(el) &#125; setTimeout(() =&gt; &#123; console.log(el.parentNode) &#125;, 2000) &#125;&#125;) 结果是这样的： 进而验证了我的猜测 寻找解决方案经过百度查阅资料，终于恍然大悟，这篇文章说到点上了vue指令与$nextTick 操作DOM的不同之处或许这篇文章跟我要解决的不是一个问题，但是已经写的很明了，把关键的地方摘抄到这： vue指令钩子函数 一个指令定义对象可以提供如下几个钩子函数 (均为可选)： bind：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。 inserted：被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)。 update：所在组件的 VNode 更新时调用，但是可能发生在其子 VNode 更新之前。指令的值可能发生了改变，也可能没有。但是你可以通过比较更新前后的值来忽略不必要的模板更新 (详细的钩子函数参数见下)。 componentUpdated：指令所在组件的 VNode 及其子 VNode 全部更新后调用。 unbind：只调用一次，指令与元素解绑时调用。 最为关键的一句，解决问题的关键inserted：被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)。 更改后的代码为12345678// 权限指令Vue.directive('has', &#123; inserted: function (el, binding) &#123; if (el.parentNode &amp;&amp; !Vue.prototype.$_has(binding.value)) &#123; el.parentNode.removeChild(el) &#125; &#125;&#125;) 总结：如果当前节点刚刚被建立,还没有被插入到DOM树中,则该节点的parentNode属性会返回null. 此时，完美解决问题。所以在用任何东西之前都熟读文档是很有必要的，免得出现问题像我这样绕一大圈","categories":[{"name":"Vue","slug":"Vue","permalink":"https://www.shengkesi.cn/categories/Vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://www.shengkesi.cn/tags/vue/"}]},{"title":"Axios 执行多个并发请求(使用Promise解决多层异步调用)","slug":"Axios-执行多个并发请求-promise","date":"2018-12-18T00:21:43.000Z","updated":"2020-06-02T11:33:57.650Z","comments":true,"path":"Axios-执行多个并发请求-promise/","link":"","permalink":"https://www.shengkesi.cn/Axios-执行多个并发请求-promise/","excerpt":"引语场景：工作中遇到一个数据接口同时依赖于另外两个接口的情况,需要两个接口返回的数据才能实现进一步操作，下面介绍 3 种方法 首先普及一下promise的一些冷门知识执行 then 和 catch 会返回一个新的 Promise ，该 Promise 最终状态根据 then 和 catch 的回调函数的执行结果决定 如果回调函数最终是 throw ， 该 Promise 是 rejected 状态 如果回调函数最终是 return ， 该 Promise 是 resolved 状态 但如果回调函数最终 return 了一个 Promise ， 该 Promise 会和回调函数的 reurn 的状态保持一致 利用js回调嵌套的方式1234567891011121314151617181920212223242526// 异步接口1: 科室列表function getDepartmentsList(callback)&#123; //模拟实现 var departmentList = Math.ceil(Math.random()*1000) setTimeout(function()&#123; callback(departmentList) &#125;,Math.random()*1000)&#125;// 异步接口2: 级别列表function getLevelList(callback)&#123; //模拟实现 var levelList = Math.ceil(Math.random()*1000)+1000 setTimeout(function()&#123; callback(levelList) &#125;,Math.random()*1000)&#125;//异步接口，列表中科室和级别码转换成对应的中文，需要前两个接口的数据function registrationList(departmentList,levelList,callback)&#123; //模拟实现 var percent = Math.ceil(departmentList/levelList*100) setTimeout(function()&#123; callback(percent) &#125;,Math.random()*1000)&#125;","text":"引语场景：工作中遇到一个数据接口同时依赖于另外两个接口的情况,需要两个接口返回的数据才能实现进一步操作，下面介绍 3 种方法 首先普及一下promise的一些冷门知识执行 then 和 catch 会返回一个新的 Promise ，该 Promise 最终状态根据 then 和 catch 的回调函数的执行结果决定 如果回调函数最终是 throw ， 该 Promise 是 rejected 状态 如果回调函数最终是 return ， 该 Promise 是 resolved 状态 但如果回调函数最终 return 了一个 Promise ， 该 Promise 会和回调函数的 reurn 的状态保持一致 利用js回调嵌套的方式1234567891011121314151617181920212223242526// 异步接口1: 科室列表function getDepartmentsList(callback)&#123; //模拟实现 var departmentList = Math.ceil(Math.random()*1000) setTimeout(function()&#123; callback(departmentList) &#125;,Math.random()*1000)&#125;// 异步接口2: 级别列表function getLevelList(callback)&#123; //模拟实现 var levelList = Math.ceil(Math.random()*1000)+1000 setTimeout(function()&#123; callback(levelList) &#125;,Math.random()*1000)&#125;//异步接口，列表中科室和级别码转换成对应的中文，需要前两个接口的数据function registrationList(departmentList,levelList,callback)&#123; //模拟实现 var percent = Math.ceil(departmentList/levelList*100) setTimeout(function()&#123; callback(percent) &#125;,Math.random()*1000)&#125; 利用es6的promise解决回调地狱问题《ES6标准入门》对Promise的描述所谓Promise，就是一个对象，用来传递异步操作的消息。它代表了某个未来才会知道的结果的事件（通常是一个异步操作），并且这个事件提供统一的API，可供进一步处理。 MDN对Promise的描述：Promise 对象是一个代理对象（代理一个值），被代理的值在Promise对象创建时可能是未知的。它允许你为异步操作的成功和失败分别绑定相应的处理方法（handlers）。 这让异步方法可以像同步方法那样返回值，但并不是立即返回最终执行结果，而是一个能代表未来出现的结果的promise对象 当时看到Promise最头疼的，就是初学者看起来匪夷所思，也是最被js程序员广为称道的特性：then函数调用链。then函数调用链，从其本质上而言，就是对多个异步过程的依次调用，本文就从这一点着手，对Promise这一特性进行研究和学习。Promise的相关知识，请参阅 Promise的链式调用 基于以上对Promise的了解，我们知道可以使用它来解决多层回调嵌套后的代码蠢笨难以维护的问题。下面请看具体代码： 每个异步接口 返回一个promise对象123456789101112131415161718192021222324252627282930// 异步接口1: 科室列表function getDepartmentsList()&#123; //模拟 return new Promise(function(resolve,reject)&#123; var departmentList = Math.ceil(Math.random()*1000) setTimeout(function()&#123; resolve(departmentList) &#125;,Math.random()*1000) &#125;) &#125;// 异步接口2: 级别列表function getLevelList()&#123; return new Promise(function(resolve,reject)&#123; var levelList = Math.ceil(Math.random()*1000)+1000 setTimeout(function()&#123; resolve(levelList) &#125;,Math.random()*1000) &#125;) &#125;// 异步接口, 列表中科室和级别码转换成对应的中文，需要前两个接口的数据function registrationList(departmentList,levelList)&#123; return new Promise(function(resolve,reject)&#123; var percent = Math.ceil(departmentList/levelList*100) setTimeout(function()&#123; resolve(percent) &#125;,Math.random()*1000) &#125;)&#125; 利用promise.all方法保证接口数据成功返回再执行操作123456Promise.all([getDepartmentsList(),getLevelList()]).then(function([departmentList,levelList])&#123; //这里写等这两个ajax都成功返回数据才执行的业务逻辑 registrationList(departmentList,levelList).then(function(percent)&#123; console.log(percent) &#125;)&#125;) Axios 解决方案(VUE)每个异步接口 返回一个axios对象12345678// 异步接口1: 科室列表getDepartmentsList () &#123; return axios.get(process.env.BASE_API_WAP + 'category/2');&#125;,// 异步接口2: 级别列表getLevelList () &#123; return axios.get(process.env.BASE_API_WAP + 'category/3');&#125; 利用axios.all方法执行多个并发请求1234567891011121314151617181920212223242526272829303132333435363738394041// 过滤数据函数filterData (targetArray) &#123; targetArray.forEach(item =&gt; &#123; for (let key in this.departmentsList) &#123; if (Number(item.departments) === this.departmentsList[key].id) &#123; item.departments = this.departmentsList[key].name; &#125; &#125; for (let key in this.levelList) &#123; if (Number(item.level) === this.levelList[key].id) &#123; item.level = this.levelList[key].name; &#125; &#125; &#125;);&#125;// 初始化init () &#123; this.title = ''; registrationList(this.current, this.pageSize, this.title).then(data =&gt; &#123; this.data = data.content; // 过滤数据 this.filterData(this.data); this.totalSize = data.total; this.pages = data.pages; &#125;).catch(error =&gt; &#123; console.log(error); &#125;);&#125;mounted () &#123; // 执行多个并发请求, 列表中科室和级别码转换成对应的中文，需要前两个接口的数据 let _this = this; axios.all([this.getDepartmentsList(), this.getLevelList()]) .then(axios.spread(function (list1, list2) &#123; _this.departmentsList = list1.data; _this.levelList = list2.data; // 两个请求现在都执行完成 _this.init(); &#125;));&#125; 总结 前端解决异步的问题时常都会遇到，Promise给前端程序员带来了新的解决思路，在它基础之上的promise的工具库（如Axios），也是在此上的封装。只要明白了其中的原理，在什么开发框架下都能灵活运用。","categories":[{"name":"Promise","slug":"Promise","permalink":"https://www.shengkesi.cn/categories/Promise/"}],"tags":[{"name":"promise","slug":"promise","permalink":"https://www.shengkesi.cn/tags/promise/"},{"name":"axios","slug":"axios","permalink":"https://www.shengkesi.cn/tags/axios/"},{"name":"ES6","slug":"ES6","permalink":"https://www.shengkesi.cn/tags/ES6/"},{"name":"回调地狱","slug":"回调地狱","permalink":"https://www.shengkesi.cn/tags/回调地狱/"}]},{"title":"你真的会检查自己系统安装的VUE版本吗？","slug":"你真的会检查自己系统安装的VUE版本吗？","date":"2018-12-17T05:55:52.000Z","updated":"2020-06-02T11:33:58.122Z","comments":true,"path":"你真的会检查自己系统安装的VUE版本吗？/","link":"","permalink":"https://www.shengkesi.cn/你真的会检查自己系统安装的VUE版本吗？/","excerpt":"引语或许你觉得我这篇文章写的很傻，和无聊，但是我跟你说，即使你从事VUE开发一段时间，也不见得求在一些小问题上所求甚解。 有些人认为的VUE版本检查命令是：1vue -V 或者1vue --version 如下图","text":"引语或许你觉得我这篇文章写的很傻，和无聊，但是我跟你说，即使你从事VUE开发一段时间，也不见得求在一些小问题上所求甚解。 有些人认为的VUE版本检查命令是：1vue -V 或者1vue --version 如下图 其实你们大错特错这哪里是检查VUE版本的，那是vue-cli的版本，vue-cli是搭vue框架的脚手架，是vue的生态环境之一 检查自己项目的VUE版本项目根目录下 package.json 中的VUE版本为安装依赖的最低支持版本，例如: “VUE”: “^2.5.13”, 要想项目运行正常，安装的VUE版本最低为 2.5.13如果要检查VUE版本，需要到node_modules中vue文件夹下的package.json中查找，或者是任意一个文件的头部注释 总结现在就目前而言，vue-cli已经进入3.0时代，与2.0的脚手架使用差别有些大了，项目构建初期的选择性更灵活了，比如 PWA ，目前VUE版本还在2.0时代，据说VUE3.0就快出来了，很期待。","categories":[{"name":"Vue","slug":"Vue","permalink":"https://www.shengkesi.cn/categories/Vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://www.shengkesi.cn/tags/vue/"}]},{"title":"element-ui table展开行，设置type=\"expand\"，如何添加表头？如何去掉展开按钮并设置成文字？","slug":"element","date":"2018-09-27T15:08:37.000Z","updated":"2020-06-02T11:33:58.109Z","comments":true,"path":"element/","link":"","permalink":"https://www.shengkesi.cn/element/","excerpt":"","text":"解决方案从项目的可维护和可扩展性考虑，还是改 element-ui 的源码，是最好的解决方案。添加了了一个属性 look, 更改了展开行中的图标 ＞，如下图 表头 label 属性，源码本身就支持，用就可以了用的时候这样用,如下:改变了之后，变为文字，如下图 用法12&lt;el-table-column label=\"操作\" type=\"expand\" look=\"查看\"&gt;&lt;/el-table-column&gt; 源代码文件夹替换替换将修改后的 lib 文件夹 替换掉你的 element-ui 中的 lib 文件夹, 路径：node-modules/element-ui点击下载","categories":[{"name":"Element-UI","slug":"Element-UI","permalink":"https://www.shengkesi.cn/categories/Element-UI/"}],"tags":[{"name":"element-ui","slug":"element-ui","permalink":"https://www.shengkesi.cn/tags/element-ui/"}]},{"title":"VUE的权限控制","slug":"VUE的权限控制","date":"2018-08-22T07:17:06.000Z","updated":"2020-06-02T11:33:57.672Z","comments":true,"path":"VUE的权限控制/","link":"","permalink":"https://www.shengkesi.cn/VUE的权限控制/","excerpt":"概述如果VUE权限控制问题困扰着你，那么这篇文章将拯救你。关于VUE的前台路由控制和视图控制是大家最需要的前端技术解决方案。 Vue-Access-Control本解决方案是基于 Vue-Access-Control 进行改造的，深度剖析了里面的路由控制和视图控制（资源控制还是后台做比较靠谱） 心路历程 权限数据由后台接口获得（权限树），但是前端不能贸然存储到本地浏览器里（localStorage、sessionStorage、Cookie等），如果被恶意篡改，麻烦可就大了!!!!! 想要用 VUEX （状态管理模式）来存储，但是网页一刷新，就会被重置成空，所以我推断 VUEX 适合用在 “无刷新” 的 APP 中；再者，权限树这么复杂的结构，并不是 VUEX 所实现的 “共享状态” 模式，只是单一的对每个页面（路由控制）、按钮（视图控制）、接口（请求控制） 针对实际的应用场景，请求控制，就是某个角色是否有调用某个接口的权限，这种后台会做权限控制的，没有权限会给你报401的，只有“路由控制”和“视图控制”是前端人员需要去解决的。 对于 Vue-Access-Control 这套权限解决方案貌似也有不完美之处，不能贴合实际的开发需要，需要稍作调整，比如路由嵌套两层还是可以使用的，要是三层及其以上就得修改递归的函数了。","text":"概述如果VUE权限控制问题困扰着你，那么这篇文章将拯救你。关于VUE的前台路由控制和视图控制是大家最需要的前端技术解决方案。 Vue-Access-Control本解决方案是基于 Vue-Access-Control 进行改造的，深度剖析了里面的路由控制和视图控制（资源控制还是后台做比较靠谱） 心路历程 权限数据由后台接口获得（权限树），但是前端不能贸然存储到本地浏览器里（localStorage、sessionStorage、Cookie等），如果被恶意篡改，麻烦可就大了!!!!! 想要用 VUEX （状态管理模式）来存储，但是网页一刷新，就会被重置成空，所以我推断 VUEX 适合用在 “无刷新” 的 APP 中；再者，权限树这么复杂的结构，并不是 VUEX 所实现的 “共享状态” 模式，只是单一的对每个页面（路由控制）、按钮（视图控制）、接口（请求控制） 针对实际的应用场景，请求控制，就是某个角色是否有调用某个接口的权限，这种后台会做权限控制的，没有权限会给你报401的，只有“路由控制”和“视图控制”是前端人员需要去解决的。 对于 Vue-Access-Control 这套权限解决方案貌似也有不完美之处，不能贴合实际的开发需要，需要稍作调整，比如路由嵌套两层还是可以使用的，要是三层及其以上就得修改递归的函数了。 实现原理详见Vue-Access-Control 具体实现授之以鱼不如授之以渔 本着这个原则，代码的主要设计思想是： 将接口所得数据（菜单树形结构）存至本地(sessionStorage); 每次刷新页面重新调取接口，更新数据到本地(sessionStorage)，保证设置权限的实时效应; 其次是用VUEX的状态机管理机制，由于父子组件相互调用问题，会导致数据不能及时从父组件更新到子组件的视图上，就是不显示在页面上；故而用VUEX来更新数据，让其获取到全局性质的值，这种设计来源于同事遇到的这个坑。 App.vue123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139&lt;template&gt; &lt;div id=\"app\" class=\"app-main\"&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import Vue from 'vue'import &#123;getBankAuth&#125; from '@/api/auth'import userPath from '@/router/fullpath'import * as util from '@/utils/util.js'export default &#123; name: 'App', data () &#123; return &#123; menuData: null, // 导航树 userAuth: null // 接口返回权限数据 &#125; &#125;, methods: &#123; getRoutes (userAuth) &#123; if (!userAuth[0].children) &#123; return console.warn(userAuth) &#125; let allowedRouter = [] // 将菜单数据转成多维数组格式 let arrayMenus = util.buildMenu(userAuth[0].children) // 将多维数组转成对象格式 let hashMenus = &#123;&#125; hashMenus = util.getPath(arrayMenus) // 全局挂载hashMenus，用于实现路由守卫 this.$root.hashMenus = hashMenus // 筛选本地路由方法 let findLocalRoute = function (array, base) &#123; let replyResult = [] array.forEach(function (route) &#123; let pathKey = (base ? base + '/' : '') + route.path if (hashMenus.hasOwnProperty(pathKey)) &#123; if (Object.prototype.toString.call(route.children) === '[object Array]') &#123; route.children = findLocalRoute(route.children, pathKey) &#125; replyResult.push(route) &#125; &#125;) if (base) &#123; return replyResult &#125; else &#123; allowedRouter = allowedRouter.concat(replyResult) &#125; &#125; let originPath = util.deepcopy(userPath) findLocalRoute(originPath) return allowedRouter &#125;, extendRoutes (allowedRouter) &#123; let vm = this let actualRouter = util.deepcopy(allowedRouter) actualRouter.map(e =&gt; &#123; // 复制子菜单信息到meta用于实现导航相关效果，非必需 if (e.children) &#123; if (!e.meta) e.meta = &#123;&#125; e.meta.children = e.children &#125; // 为动态路由添加独享守卫 return e.beforeEnter = function (to, from, next) &#123; if (vm.$root.hashMenus[to.path]) &#123; next() // 按钮权限检验方法 Vue.prototype.$_has = function (p) &#123; let permission = false // 校验权限 this.hashButtons.forEach(item =&gt; &#123; if (item.hasOwnProperty(to.path)) &#123; if (item[to.path].indexOf(p) !== -1) &#123; permission = true &#125; &#125; &#125;) return permission &#125; &#125; else &#123; next('/401') &#125; &#125; &#125;) // let originPath = util.deepcopy(userPath) let originPath = actualRouter // 注入路由 vm.$router.addRoutes(originPath.concat([&#123; path: '*', redirect: '/login' &#125;])) &#125;, // 获取权限数据 getAuthority (role) &#123; let vm = this // 检查登录状态 let localUser = util.session('token') if (!localUser || !localUser.authorities) &#123; return vm.$router.push(&#123; path: '/login', query: &#123; from: vm.$router.currentRoute.path &#125; &#125;) &#125; if (role === 'bank') &#123; getBankAuth().then(data =&gt; &#123; let userAuth = data // 获得实际路由 let allowedRouter = vm.getRoutes(userAuth) // 若无可用路由限制访问 if (!allowedRouter || !allowedRouter.length) &#123; util.session('token', '') return document.body.innerHTML = ('&lt;h1&gt;账号访问受限，请联系系统管理员！&lt;/h1&gt;') &#125; // 动态注入路由 vm.extendRoutes(allowedRouter) // 保存数据用作他处，非必需 vm.menuData = allowedRouter vm.userAuth = userAuth &#125;).catch(error =&gt; &#123; console.log(error) &#125;) &#125; &#125; &#125;, created () &#123; this.getAuthority('bank') &#125;&#125;&lt;/script&gt;&lt;style lang=\"scss\"&gt; @import 'assets/sass/sks.scss'; @import 'assets/fonts/iconfont.css';/*阿里字体图标*/ @import 'assets/sass/table.scss';/*table样式*/ @import 'assets/sass/dialog.scss'; /* dialog样式 */ .app-main &#123; width: 100%; height: 100%; overflow: auto; &#125;&lt;/style&gt; 代码剖析Layout.vue1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950export default &#123; name: 'layout', created () &#123; this.getNav() &#125;, methods: &#123; getNav () &#123; // 设置导航 let menus = this.$parent.menuData if (!localStorage.navBankArray) &#123; if (menus) &#123; // 整理导航数据结构 menus.forEach((item, index) =&gt; &#123; if (index === 0) &#123; menus[index].active = true &#125; else &#123; menus[index].active = false &#125; &#125;) this.routerMap = menus localStorage.navBankArray = JSON.stringify(menus) &#125; &#125; else &#123; let tempBankArray = JSON.parse(localStorage.navBankArray) this.routerMap = tempBankArray &#125; &#125;, logout () &#123; // 清除session util.session('token', '') // 清除菜单权限 this.$root.hashMenus = &#123;&#125; // 退出登录 logoutBank() .then(res =&gt; &#123; store.commit('logout', this) this.$router.replace(&#123;name: 'Login'&#125;) localStorage.removeItem('navBankArray') &#125;) .catch(error =&gt; &#123; console.log(error) &#125;) &#125; &#125;, watch: &#123; $route () &#123; this.getNav() &#125; &#125;&#125;","categories":[{"name":"Vue","slug":"Vue","permalink":"https://www.shengkesi.cn/categories/Vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://www.shengkesi.cn/tags/vue/"},{"name":"permission","slug":"permission","permalink":"https://www.shengkesi.cn/tags/permission/"}]},{"title":"Hello World","slug":"hello-world","date":"2018-08-21T07:17:06.000Z","updated":"2020-05-20T17:09:17.000Z","comments":true,"path":"hello-world/","link":"","permalink":"https://www.shengkesi.cn/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://www.shengkesi.cn/categories/Hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://www.shengkesi.cn/tags/hexo/"}]}]}