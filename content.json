{"meta":{"title":"盛克思的博客","subtitle":"盛克思前端技术分享","description":"对于VUE、NodeJS、angular1、webpack、gulp 等相关技术的实战经验分享","author":"shengkesi","url":"https://www.shengkesi.cn"},"pages":[{"title":"about","date":"2018-09-17T00:46:50.000Z","updated":"2018-09-19T01:20:04.000Z","comments":true,"path":"about/index.html","permalink":"https://www.shengkesi.cn/about/index.html","excerpt":"","text":"盛克思简介 About me13年3月从事前端开发至今 现研究方向现研究mock.js(模拟接口请求)，eslint + prettier(语法检查和格式化工具)，来辅助vue-cli3项目的开发项目还在努力维护中，为保证功能完善，给大家铺路。 2018研究vue2.0 VUEX状态管理机制 webpack 等"},{"title":"all-archives","date":"2018-12-24T13:25:23.450Z","updated":"2018-11-29T08:39:04.000Z","comments":false,"path":"all-archives/index.html","permalink":"https://www.shengkesi.cn/all-archives/index.html","excerpt":"","text":""},{"title":"","date":"2018-12-24T13:25:23.697Z","updated":"2018-11-29T08:39:04.000Z","comments":true,"path":"all-categories/package.json","permalink":"https://www.shengkesi.cn/all-categories/package.json","excerpt":"","text":"{\"dependencies\":{\"hexo-deployer-git\":\"^0.3.0\"}}"},{"title":"all-tags","date":"2018-12-24T13:25:23.808Z","updated":"2018-11-29T08:39:04.000Z","comments":false,"path":"all-tags/index.html","permalink":"https://www.shengkesi.cn/all-tags/index.html","excerpt":"","text":""},{"title":"all-categories","date":"2018-12-24T13:25:23.566Z","updated":"2018-11-29T08:39:04.000Z","comments":false,"path":"all-categories/index.html","permalink":"https://www.shengkesi.cn/all-categories/index.html","excerpt":"","text":""}],"posts":[{"title":"Axios 执行多个并发请求(使用Promise解决多层异步调用)","slug":"Axios-执行多个并发请求-promise","date":"2018-12-18T00:21:43.000Z","updated":"2018-12-18T05:33:10.000Z","comments":true,"path":"2018/12/18/Axios-执行多个并发请求-promise/","link":"","permalink":"https://www.shengkesi.cn/2018/12/18/Axios-执行多个并发请求-promise/","excerpt":"","text":"引语场景：工作中遇到一个数据接口同时依赖于另外两个接口的情况,需要两个接口返回的数据才能实现进一步操作，下面介绍 3 种方法 利用js回调嵌套的方式1234567891011121314151617181920212223242526// 异步接口1: 科室列表function getDepartmentsList(callback)&#123; //模拟实现 var onlinePerson = Math.ceil(Math.random()*1000) setTimeout(function()&#123; callback(onlinePerson) &#125;,Math.random()*1000)&#125;// 异步接口2: 级别列表function getLevelList(callback)&#123; //模拟实现 var RegPerson = Math.ceil(Math.random()*1000)+1000 setTimeout(function()&#123; callback(RegPerson) &#125;,Math.random()*1000)&#125;//异步接口，列表中科室和级别码转换成对应的中文，需要前两个接口的数据function calOnlinePercent(onlinePerson,RegPerson,callback)&#123; //模拟实现 var percent = Math.ceil(onlinePerson/RegPerson*100) setTimeout(function()&#123; callback(percent) &#125;,Math.random()*1000)&#125; 利用es6的promise解决回调地狱问题《ES6标准入门》对Promise的描述所谓Promise，就是一个对象，用来传递异步操作的消息。它代表了某个未来才会知道的结果的事件（通常是一个异步操作），并且这个事件提供统一的API，可供进一步处理。 MDN对Promise的描述：Promise 对象是一个代理对象（代理一个值），被代理的值在Promise对象创建时可能是未知的。它允许你为异步操作的成功和失败分别绑定相应的处理方法（handlers）。 这让异步方法可以像同步方法那样返回值，但并不是立即返回最终执行结果，而是一个能代表未来出现的结果的promise对象 当时看到Promise最头疼的，就是初学者看起来匪夷所思，也是最被js程序员广为称道的特性：then函数调用链。then函数调用链，从其本质上而言，就是对多个异步过程的依次调用，本文就从这一点着手，对Promise这一特性进行研究和学习。Promise的相关知识，请参阅 Promise的链式调用 基于以上对Promise的了解，我们知道可以使用它来解决多层回调嵌套后的代码蠢笨难以维护的问题。下面请看具体代码： 每个异步接口 返回一个promise对象123456789101112131415161718192021222324252627282930// 异步接口1: 科室列表function getDepartmentsList()&#123; //模拟 return new Promise(function(resolve,reject)&#123; var onlinePerson = Math.ceil(Math.random()*1000) setTimeout(function()&#123; resolve(onlinePerson) &#125;,Math.random()*1000) &#125;) &#125;// 异步接口2: 级别列表function getLevelList()&#123; return new Promise(function(resolve,reject)&#123; var RegPerson = Math.ceil(Math.random()*1000)+1000 setTimeout(function()&#123; resolve(RegPerson) &#125;,Math.random()*1000) &#125;) &#125;// 异步接口, 列表中科室和级别码转换成对应的中文，需要前两个接口的数据function calOnlinePercent(onlinePerson,RegPerson)&#123; return new Promise(function(resolve,reject)&#123; var percent = Math.ceil(onlinePerson/RegPerson*100) setTimeout(function()&#123; resolve(percent) &#125;,Math.random()*1000) &#125;)&#125; 利用promise.all方法保证接口数据成功返回再执行操作123456Promise.all([getDepartmentsList(),getLevelList()]).then(function([onlinePerson,RegPerson])&#123; //这里写等这两个ajax都成功返回数据才执行的业务逻辑 calOnlinePercent(onlinePerson,RegPerson).then(function(percent)&#123; console.log(percent) &#125;)&#125;) Axios 解决方案(VUE)每个异步接口 返回一个axios对象12345678// 异步接口1: 科室列表getDepartmentsList () &#123; return axios.get(process.env.BASE_API_WAP + &apos;category/2&apos;);&#125;,// 异步接口2: 级别列表getLevelList () &#123; return axios.get(process.env.BASE_API_WAP + &apos;category/3&apos;);&#125; 利用axios.all方法执行多个并发请求1234567891011121314151617181920212223242526272829303132333435363738394041424344// 过滤数据函数filterData (targetArray) &#123; targetArray.forEach(item =&gt; &#123; if (typeof item.meetingTime === &apos;number&apos;) &#123; item.meetingTime = util.timestampFilter(item.meetingTime); &#125; for (let key in this.departmentsList) &#123; if (Number(item.departments) === this.departmentsList[key].id) &#123; item.departments = this.departmentsList[key].name; &#125; &#125; for (let key in this.levelList) &#123; if (Number(item.level) === this.levelList[key].id) &#123; item.level = this.levelList[key].name; &#125; &#125; &#125;);&#125;// 初始化init () &#123; this.title = &apos;&apos;; registrationList(this.current, this.pageSize, this.title).then(data =&gt; &#123; this.data = data.content; // 过滤数据 this.filterData(this.data); this.totalSize = data.total; this.pages = data.pages; &#125;).catch(error =&gt; &#123; console.log(error); &#125;);&#125;mounted () &#123; // 执行多个并发请求, 列表中科室和级别码转换成对应的中文，需要前两个接口的数据 let _this = this; axios.all([this.getDepartmentsList(), this.getLevelList()]) .then(axios.spread(function (list1, list2) &#123; _this.departmentsList = list1.data; _this.levelList = list2.data; // 两个请求现在都执行完成 _this.init(); &#125;));&#125; 总结 前端解决异步的问题时常都会遇到，Promise给前端程序员带来了新的解决思路，在它基础之上的promise的工具库（如Axios），也是在此上的封装。只要明白了其中的原理，在什么开发框架下都能灵活运用。","categories":[{"name":"Vue","slug":"Vue","permalink":"https://www.shengkesi.cn/categories/Vue/"},{"name":"Promise","slug":"Vue/Promise","permalink":"https://www.shengkesi.cn/categories/Vue/Promise/"},{"name":"ES6","slug":"Vue/Promise/ES6","permalink":"https://www.shengkesi.cn/categories/Vue/Promise/ES6/"}],"tags":[{"name":"promise","slug":"promise","permalink":"https://www.shengkesi.cn/tags/promise/"},{"name":"axios","slug":"axios","permalink":"https://www.shengkesi.cn/tags/axios/"},{"name":"ES6","slug":"ES6","permalink":"https://www.shengkesi.cn/tags/ES6/"},{"name":"回调地狱","slug":"回调地狱","permalink":"https://www.shengkesi.cn/tags/回调地狱/"}]},{"title":"你真的会检查自己系统安装的VUE版本吗？","slug":"你真的会检查自己系统安装的VUE版本吗？","date":"2018-12-17T05:55:52.000Z","updated":"2019-01-22T23:50:48.184Z","comments":true,"path":"2018/12/17/你真的会检查自己系统安装的VUE版本吗？/","link":"","permalink":"https://www.shengkesi.cn/2018/12/17/你真的会检查自己系统安装的VUE版本吗？/","excerpt":"","text":"引语或许你觉得我这篇文章写的很傻，和无聊，但是我跟你说，即使你从事VUE开发一段时间，也不见得求在一些小问题上所求甚解。 有些人认为的VUE版本检查命令是：1vue -V 或者1vue --version 如下图 其实你们大错特错这哪里是检查VUE版本的，那是vue-cli的版本，vue-cli是搭vue框架的脚手架，是vue的生态环境之一 检查自己项目的VUE版本()请看自己项目根目录中package.json感谢大神对我错误的指点，对此问题更正一下，如果要检查VUE版本，需要到node_modules中vue文件夹下的package.json中查找，或者是任意一个文件的头部注释 总结现在就目前而言，vue-cli已经进入3.0时代，与2.0的脚手架使用差别有些大了，项目构建初期的选择性更灵活了，比如 PWA ，目前VUE版本还在2.0时代，据说VUE3.0就快出来了，很期待。","categories":[{"name":"Vue","slug":"Vue","permalink":"https://www.shengkesi.cn/categories/Vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://www.shengkesi.cn/tags/vue/"}]},{"title":"Page not found","slug":"/404.html","date":"2018-12-16T16:54:08.480Z","updated":"2018-12-17T08:38:42.000Z","comments":false,"path":"2018/12/17//404.html/","link":"","permalink":"https://www.shengkesi.cn/2018/12/17/404.html/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"element-ui table展开行，设置type=\"expand\"，如何添加表头？如何去掉展开按钮并设置成文字？","slug":"element","date":"2018-09-27T15:08:37.000Z","updated":"2018-10-01T00:57:22.000Z","comments":true,"path":"2018/09/27/element/","link":"","permalink":"https://www.shengkesi.cn/2018/09/27/element/","excerpt":"","text":"解决方案从项目的可维护和可扩展性考虑，还是改 element-ui 的源码，是最好的解决方案。添加了了一个属性 look, 更改了展开行中的图标 ＞，如下图 表头 label 属性，源码本身就支持，用就可以了用的时候这样用,如下:改变了之后，变为文字，如下图 用法12&lt;el-table-column label=&quot;操作&quot; type=&quot;expand&quot; look=&quot;查看&quot;&gt;&lt;/el-table-column&gt; 源代码文件夹替换替换将修改后的 lib 文件夹 替换掉你的 element-ui 中的 lib 文件夹, 路径：node-modules/element-ui点击下载","categories":[],"tags":[]},{"title":"VUE的权限控制","slug":"VUE的权限控制","date":"2018-08-22T07:17:06.000Z","updated":"2018-09-10T09:26:46.000Z","comments":true,"path":"2018/08/22/VUE的权限控制/","link":"","permalink":"https://www.shengkesi.cn/2018/08/22/VUE的权限控制/","excerpt":"","text":"概述如果VUE权限控制问题困扰着你，那么这篇文章将拯救你。关于VUE的前台路由控制和视图控制是大家最需要的前端技术解决方案。 Vue-Access-Control本解决方案是基于 Vue-Access-Control 进行改造的，深度剖析了里面的路由控制和视图控制（资源控制还是后台做比较靠谱） 心路历程 权限数据由后台接口获得（权限树），但是前端不能贸然存储到本地浏览器里（localStorage、sessionStorage、Cookie等），如果被恶意篡改，麻烦可就大了!!!!! 想要用 VUEX （状态管理模式）来存储，但是网页一刷新，就会被重置成空，所以我推断 VUEX 适合用在 “无刷新” 的 APP 中；再者，权限树这么复杂的结构，并不是 VUEX 所实现的 “共享状态” 模式，只是单一的对每个页面（路由控制）、按钮（视图控制）、接口（请求控制） 针对实际的应用场景，请求控制，就是某个角色是否有调用某个接口的权限，这种后台会做权限控制的，没有权限会给你报401的，只有“路由控制”和“视图控制”是前端人员需要去解决的。 对于 Vue-Access-Control 这套权限解决方案貌似也有不完美之处，不能贴合实际的开发需要，需要稍作调整，比如路由嵌套两层还是可以使用的，要是三层及其以上就得修改递归的函数了。 实现原理详见Vue-Access-Control 具体实现App.vue123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139&lt;template&gt; &lt;div id=&quot;app&quot; class=&quot;app-main&quot;&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import Vue from &apos;vue&apos;import &#123;getBankAuth&#125; from &apos;@/api/auth&apos;import userPath from &apos;@/router/fullpath&apos;import * as util from &apos;@/utils/util.js&apos;export default &#123; name: &apos;App&apos;, data () &#123; return &#123; menuData: null, // 导航树 userAuth: null // 接口返回权限数据 &#125; &#125;, methods: &#123; getRoutes (userAuth) &#123; if (!userAuth[0].children) &#123; return console.warn(userAuth) &#125; let allowedRouter = [] // 将菜单数据转成多维数组格式 let arrayMenus = util.buildMenu(userAuth[0].children) // 将多维数组转成对象格式 let hashMenus = &#123;&#125; hashMenus = util.getPath(arrayMenus) // 全局挂载hashMenus，用于实现路由守卫 this.$root.hashMenus = hashMenus // 筛选本地路由方法 let findLocalRoute = function (array, base) &#123; let replyResult = [] array.forEach(function (route) &#123; let pathKey = (base ? base + &apos;/&apos; : &apos;&apos;) + route.path if (hashMenus.hasOwnProperty(pathKey)) &#123; if (Object.prototype.toString.call(route.children) === &apos;[object Array]&apos;) &#123; route.children = findLocalRoute(route.children, pathKey) &#125; replyResult.push(route) &#125; &#125;) if (base) &#123; return replyResult &#125; else &#123; allowedRouter = allowedRouter.concat(replyResult) &#125; &#125; let originPath = util.deepcopy(userPath) findLocalRoute(originPath) return allowedRouter &#125;, extendRoutes (allowedRouter) &#123; let vm = this let actualRouter = util.deepcopy(allowedRouter) actualRouter.map(e =&gt; &#123; // 复制子菜单信息到meta用于实现导航相关效果，非必需 if (e.children) &#123; if (!e.meta) e.meta = &#123;&#125; e.meta.children = e.children &#125; // 为动态路由添加独享守卫 return e.beforeEnter = function (to, from, next) &#123; if (vm.$root.hashMenus[to.path]) &#123; next() // 按钮权限检验方法 Vue.prototype.$_has = function (p) &#123; let permission = false // 校验权限 this.hashButtons.forEach(item =&gt; &#123; if (item.hasOwnProperty(to.path)) &#123; if (item[to.path].indexOf(p) !== -1) &#123; permission = true &#125; &#125; &#125;) return permission &#125; &#125; else &#123; next(&apos;/401&apos;) &#125; &#125; &#125;) // let originPath = util.deepcopy(userPath) let originPath = actualRouter // 注入路由 vm.$router.addRoutes(originPath.concat([&#123; path: &apos;*&apos;, redirect: &apos;/login&apos; &#125;])) &#125;, // 获取权限数据 getAuthority (role) &#123; let vm = this // 检查登录状态 let localUser = util.session(&apos;token&apos;) if (!localUser || !localUser.authorities) &#123; return vm.$router.push(&#123; path: &apos;/login&apos;, query: &#123; from: vm.$router.currentRoute.path &#125; &#125;) &#125; if (role === &apos;bank&apos;) &#123; getBankAuth().then(data =&gt; &#123; let userAuth = data // 获得实际路由 let allowedRouter = vm.getRoutes(userAuth) // 若无可用路由限制访问 if (!allowedRouter || !allowedRouter.length) &#123; util.session(&apos;token&apos;, &apos;&apos;) return document.body.innerHTML = (&apos;&lt;h1&gt;账号访问受限，请联系系统管理员！&lt;/h1&gt;&apos;) &#125; // 动态注入路由 vm.extendRoutes(allowedRouter) // 保存数据用作他处，非必需 vm.menuData = allowedRouter vm.userAuth = userAuth &#125;).catch(error =&gt; &#123; console.log(error) &#125;) &#125; &#125; &#125;, created () &#123; this.getAuthority(&apos;bank&apos;) &#125;&#125;&lt;/script&gt;&lt;style lang=&quot;scss&quot;&gt; @import &apos;assets/sass/sks.scss&apos;; @import &apos;assets/fonts/iconfont.css&apos;;/*阿里字体图标*/ @import &apos;assets/sass/table.scss&apos;;/*table样式*/ @import &apos;assets/sass/dialog.scss&apos;; /* dialog样式 */ .app-main &#123; width: 100%; height: 100%; overflow: auto; &#125;&lt;/style&gt; 代码剖析Layout.vue1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950export default &#123; name: &apos;layout&apos;, created () &#123; this.getNav() &#125;, methods: &#123; getNav () &#123; // 设置导航 let menus = this.$parent.menuData if (!localStorage.navBankArray) &#123; if (menus) &#123; // 整理导航数据结构 menus.forEach((item, index) =&gt; &#123; if (index === 0) &#123; menus[index].active = true &#125; else &#123; menus[index].active = false &#125; &#125;) this.routerMap = menus localStorage.navBankArray = JSON.stringify(menus) &#125; &#125; else &#123; let tempBankArray = JSON.parse(localStorage.navBankArray) this.routerMap = tempBankArray &#125; &#125;, logout () &#123; // 清除session util.session(&apos;token&apos;, &apos;&apos;) // 清除菜单权限 this.$root.hashMenus = &#123;&#125; // 退出登录 logoutBank() .then(res =&gt; &#123; store.commit(&apos;logout&apos;, this) this.$router.replace(&#123;name: &apos;Login&apos;&#125;) localStorage.removeItem(&apos;navBankArray&apos;) &#125;) .catch(error =&gt; &#123; console.log(error) &#125;) &#125; &#125;, watch: &#123; $route () &#123; this.getNav() &#125; &#125;&#125;","categories":[{"name":"VUE","slug":"VUE","permalink":"https://www.shengkesi.cn/categories/VUE/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://www.shengkesi.cn/tags/vue/"},{"name":"permission","slug":"permission","permalink":"https://www.shengkesi.cn/tags/permission/"}]},{"title":"Hello World","slug":"hello-world","date":"2018-08-21T07:17:06.000Z","updated":"2018-09-10T09:33:16.000Z","comments":true,"path":"2018/08/21/hello-world/","link":"","permalink":"https://www.shengkesi.cn/2018/08/21/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://www.shengkesi.cn/categories/Hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://www.shengkesi.cn/tags/hexo/"}]}]}